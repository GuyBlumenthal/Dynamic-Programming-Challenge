Timer unit: 1e-09 s

Total time: 0.000586502 s
File: /home/gblum/dev/dpc/ComputeExpectedStageCosts.py
Function: compute_expected_stage_cost_solver at line 27

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    27                                           @profile
    28                                           def compute_expected_stage_cost_solver(C: Const, K: int) -> Tuple[np.array, np.array]:
    29         8      51186.0   6398.2      8.7      costs_row = np.array([
    30         4       3987.0    996.8      0.7          -1,                # Cost for action 0 (None)
    31         4      13485.0   3371.2      2.3          C.lam_weak - 1,    # Cost for action 1 (Weak)
    32         4       2845.0    711.2      0.5          C.lam_strong - 1   # Cost for action 2 (Strong)
    33                                               ])
    34                                           
    35         8     112998.0  14124.8     19.3      b = np.concatenate((
    36         4     193361.0  48340.2     33.0          np.repeat(costs_row[0], K),  # Column 0 of Q
    37         4      69488.0  17372.0     11.8          np.repeat(costs_row[1], K),  # Column 1 of Q
    38         4      53144.0  13286.0      9.1          np.repeat(costs_row[2], K)   # Column 2 of Q
    39                                               ))
    40                                           
    41         4      83051.0  20762.8     14.2      Q = b.reshape((K, C.L), order='F')
    42                                           
    43         4       2957.0    739.2      0.5      return Q, b

Total time: 0.0778929 s
File: /home/gblum/dev/dpc/utils.py
Function: custom_state_space.<locals>._build_d_recursive at line 112

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   112                                               @profile
   113                                               def _build_d_recursive(y, v, current_d_list, current_d_sum, d_index, zero_seen):
   114                                                   """
   115                                                   Recursively builds the D-vector (d1, ..., dM) for a given
   116                                                   (y, v) prefix.
   117                                           
   118                                                   Pruning:
   119                                                   - sum(d) > X-1
   120                                                   - Trailing zeros (if d_i=0, all d_j for j>i must be 0)
   121                                                   - d2=0 if d1=0
   122                                                   """
   123                                                   # --- Base Case: D-vector is complete ---
   124      3006    2182542.0    726.1      2.8          if d_index == M:
   125                                                       # D-vector is built, now start building the H-vector
   126                                                       nonlocal current_index
   127                                           
   128                                                       # 1. Build the list of allowed H-options for this d_tuple
   129                                                       # h1 always has all options
   130      3816    9791282.0   2565.8     12.6              h_iterables = [h_options_all] + [
   131                                                           h_options_default if current_d_list[i] == 0 else h_options_all
   132      1908    1908995.0   1000.5      2.5                  for i in range(1, M)
   133                                                       ]
   134                                           
   135      1908    2133435.0   1118.2      2.7              prefix = (y, v) + tuple(current_d_list)
   136                                           
   137                                                       # 2. Loop over the product of these allowed H-options
   138      7848    6125267.0    780.5      7.9              for h_tuple in product(*h_iterables):
   139      5940    5602616.0    943.2      7.2                  state = prefix + h_tuple
   140      5940    5140580.0    865.4      6.6                  state_to_index_dict[state] = current_index
   141      5940    3936425.0    662.7      5.1                  current_index += 1
   142                                           
   143      1908    1132637.0    593.6      1.5              return
   144                                           
   145                                                   # --- Recursive Step: Add d_i ---
   146      1098     729352.0    664.3      0.9          if d_index == 0:
   147       126      86998.0    690.5      0.1              d_options = S_d1
   148       972     561443.0    577.6      0.7          elif zero_seen:
   149                                                       d_options = S_d0
   150                                                   else:
   151       972     644428.0    663.0      0.8              d_options = S_d
   152                                           
   153      6570    4237235.0    644.9      5.4          for d in d_options:
   154                                                       # 1. Sum constraint
   155      5472    4066298.0    743.1      5.2              if current_d_sum + d > X_limit:
   156      2466    1248426.0    506.3      1.6                  continue
   157                                           
   158                                                       # 3. d1/d2 constraint (d1=0 -> d2>0)
   159                                                       # d_index == 1 is d2
   160      3006    1935586.0    643.9      2.5              if d_index == 1:
   161      2034    1452211.0    714.0      1.9                  d1 = current_d_list[0]
   162      2034    1133044.0    557.1      1.5                  d2 = d
   163      2034    1371580.0    674.3      1.8                  if d1 <= 0 and d2 == 0:
   164       126      69650.0    552.8      0.1                      continue
   165                                           
   166                                                       # Recurse with the added d
   167      2880    2141696.0    743.6      2.7              current_d_list[d_index] = d
   168      5760   11564254.0   2007.7     14.8              _build_d_recursive(
   169      2880    1621457.0    563.0      2.1                  y, v,
   170      2880    1567491.0    544.3      2.0                  current_d_list,
   171      2880    1640573.0    569.6      2.1                  current_d_sum + d,
   172      2880    1714115.0    595.2      2.2                  d_index + 1,
   173                                                           # Update zero_seen flag:
   174                                                           # (zero_seen is True if it was already True, OR
   175                                                           # if we are adding a zero *after* d1)
   176      2880    2153320.0    747.7      2.8                  zero_seen or (d_index > 0 and d == 0)
   177                                                       )

Total time: 0.146599 s
File: /home/gblum/dev/dpc/utils.py
Function: custom_state_space at line 83

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    83                                           @profile
    84                                           def custom_state_space(C: Const) -> Tuple[int, Dict[Tuple[int, ...], int]]:
    85                                               """
    86                                               Computes the state space and returns a state -> index dictionary
    87                                               using a recursive, pruning-based generation method.
    88                                           
    89                                               This function maintains the strict lexicographical ordering
    90                                               from the problem statement, ensuring the state-to-index
    91                                               mapping is identical to the original 'itertools.product' method,
    92                                               but is significantly faster by pruning invalid branches early.
    93                                               """
    94                                           
    95         4       9157.0   2289.2      0.0      state_to_index_dict = {}
    96         4      10373.0   2593.2      0.0      current_index = 0
    97                                           
    98                                               # --- Cache constants from C for minor speedup ---
    99         4      80379.0  20094.8      0.1      S_y, S_v = C.S_y, C.S_v
   100         4      77301.0  19325.2      0.1      S_d, S_d1 = C.S_d, C.S_d1
   101         4      24660.0   6165.0      0.0      S_h, S_h_default = C.S_h, C.S_h[0]
   102         4      39772.0   9943.0      0.0      M, X_limit = C.M, C.X - 1
   103                                           
   104                                               # Pre-build the two possible lists for H-options
   105         4       5617.0   1404.2      0.0      h_options_all = S_h
   106         4       7900.0   1975.0      0.0      h_options_default = [S_h_default]
   107                                           
   108                                               # Pre build an empty D-options list
   109         4       5435.0   1358.8      0.0      S_d0 = [0]
   110                                           
   111                                               # ================== D-Vector Recursive Builder ==================
   112         8    4155359.0 519419.9      2.8      @profile
   113         8      22844.0   2855.5      0.0      def _build_d_recursive(y, v, current_d_list, current_d_sum, d_index, zero_seen):
   114                                                   """
   115                                                   Recursively builds the D-vector (d1, ..., dM) for a given
   116                                                   (y, v) prefix.
   117                                           
   118                                                   Pruning:
   119                                                   - sum(d) > X-1
   120                                                   - Trailing zeros (if d_i=0, all d_j for j>i must be 0)
   121                                                   - d2=0 if d1=0
   122                                                   """
   123                                                   # --- Base Case: D-vector is complete ---
   124                                                   if d_index == M:
   125                                                       # D-vector is built, now start building the H-vector
   126                                                       nonlocal current_index
   127                                           
   128                                                       # 1. Build the list of allowed H-options for this d_tuple
   129                                                       # h1 always has all options
   130                                                       h_iterables = [h_options_all] + [
   131                                                           h_options_default if current_d_list[i] == 0 else h_options_all
   132                                                           for i in range(1, M)
   133                                                       ]
   134                                           
   135                                                       prefix = (y, v) + tuple(current_d_list)
   136                                           
   137                                                       # 2. Loop over the product of these allowed H-options
   138                                                       for h_tuple in product(*h_iterables):
   139                                                           state = prefix + h_tuple
   140                                                           state_to_index_dict[state] = current_index
   141                                                           current_index += 1
   142                                           
   143                                                       return
   144                                           
   145                                                   # --- Recursive Step: Add d_i ---
   146                                                   if d_index == 0:
   147                                                       d_options = S_d1
   148                                                   elif zero_seen:
   149                                                       d_options = S_d0
   150                                                   else:
   151                                                       d_options = S_d
   152                                           
   153                                                   for d in d_options:
   154                                                       # 1. Sum constraint
   155                                                       if current_d_sum + d > X_limit:
   156                                                           continue
   157                                           
   158                                                       # 3. d1/d2 constraint (d1=0 -> d2>0)
   159                                                       # d_index == 1 is d2
   160                                                       if d_index == 1:
   161                                                           d1 = current_d_list[0]
   162                                                           d2 = d
   163                                                           if d1 <= 0 and d2 == 0:
   164                                                               continue
   165                                           
   166                                                       # Recurse with the added d
   167                                                       current_d_list[d_index] = d
   168                                                       _build_d_recursive(
   169                                                           y, v,
   170                                                           current_d_list,
   171                                                           current_d_sum + d,
   172                                                           d_index + 1,
   173                                                           # Update zero_seen flag:
   174                                                           # (zero_seen is True if it was already True, OR
   175                                                           # if we are adding a zero *after* d1)
   176                                                           zero_seen or (d_index > 0 and d == 0)
   177                                                       )
   178                                           
   179                                               # The outer loops *must* be y, then v, to maintain order
   180        34      37166.0   1093.1      0.0      for y in S_y:
   181       156     127926.0    820.0      0.1          for v in S_v:
   182       126     212697.0   1688.1      0.1              current_d_list_for_v = [0] * M
   183                                                       # Start the recursion for the D-vector
   184       126  141758666.0 1.13e+06     96.7              _build_d_recursive(y, v, current_d_list_for_v, 0, 0, False)
   185                                           
   186         4      23434.0   5858.5      0.0      return len(state_to_index_dict), state_to_index_dict

Total time: 0.277684 s
File: /home/gblum/dev/dpc/ComputeTransitionProbabilities.py
Function: compute_transition_probabilities_sparse at line 28

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    28                                           @profile
    29                                           def compute_transition_probabilities_sparse(C:Const, state_to_index_dict, K) -> list:
    30                                               """Computes the transition probability matrix P as a list of sparse matrices."""
    31                                           
    32                                               # Each action in C.input_space will have its own sparse probability matrix
    33         4      36892.0   9223.0      0.0      num_inputs = len(C.input_space)
    34                                           
    35                                               # A calculated probability P[curr_state, next_state, action] is stored as
    36                                               #   coo_data[action] = P[curr_state, next_state, action]
    37                                               #   coo_cols[action] = curr_state
    38                                               #   coo_rows[action] = next_state
    39         4      29799.0   7449.8      0.0      coo_data = [[] for input_i in range(num_inputs)]
    40         4      16614.0   4153.5      0.0      coo_cols = [[] for input_i in range(num_inputs)]
    41         4      15436.0   3859.0      0.0      coo_rows = [[] for input_i in range(num_inputs)]
    42                                           
    43                                               # Helper functions for populating coo table
    44         4      32686.0   8171.5      0.0      append_data = [l.append for l in coo_data]
    45         4      15789.0   3947.2      0.0      append_rows = [l.append for l in coo_rows]
    46         4      19122.0   4780.5      0.0      append_cols = [l.append for l in coo_cols]
    47                                           
    48                                               # Store variables once instead of recalculating
    49         4       6755.0   1688.8      0.0      Y_limit = C.Y - 1
    50         4       8959.0   2239.8      0.0      G_limit = (C.G - 1) / 2
    51         4      26515.0   6628.8      0.0      M = C.M
    52         4       4368.0   1092.0      0.0      X, D_min = C.X, C.D_min
    53         4       6990.0   1747.5      0.0      V_max, g = C.V_max, C.g
    54         4       5543.0   1385.8      0.0      S_h, S_h_0 = C.S_h, C.S_h[0]
    55         4       5295.0   1323.8      0.0      p_height = 1 / len(S_h)
    56         4       5534.0   1383.5      0.0      U_strong_prob = 1 / (2 * C.V_dev + 1)
    57         4      32601.0   8150.2      0.0      W_v = C.W_v
    58                                           
    59         4       4294.0   1073.5      0.0      StateVar_Y = 0
    60         4       2876.0    719.0      0.0      StateVar_V = 1
    61         4       4764.0   1191.0      0.0      StateVar_D_1 = 2
    62         4       3662.0    915.5      0.0      StateVar_D_2 = StateVar_D_1 + 1
    63         4       2948.0    737.0      0.0      StateVar_D_M = StateVar_D_1 + M - 1
    64         4       2691.0    672.8      0.0      StateVar_H_1 = StateVar_D_M + 1
    65         4       2136.0    534.0      0.0      StateVar_H_2 = StateVar_H_1 + 1
    66         4       2941.0    735.2      0.0      StateVar_H_M = StateVar_H_1 + M - 1
    67                                           
    68         4       4871.0   1217.8      0.0      U = [
    69         4       4689.0   1172.2      0.0          [0, C.U_no_flap, 1, [0]],
    70         4       3762.0    940.5      0.0          [1, C.U_weak, 1, [0]],
    71         4       4302.0   1075.5      0.0          [2, C.U_strong, U_strong_prob, W_v]
    72                                               ]
    73                                           
    74      5944    3619316.0    608.9      1.3      for state_i, state_index in state_to_index_dict.items():
    75      5940    7321525.0   1232.6      2.6          y_j = min(Y_limit, max(0, state_i[StateVar_Y] + state_i[StateVar_V]))
    76      5940    3754286.0    632.0      1.4          if state_i[StateVar_D_1] == 0:
    77      1800    1627891.0    904.4      0.6              if abs(state_i[StateVar_Y] - state_i[StateVar_H_1]) > G_limit:
    78      1580     686177.0    434.3      0.2                  continue
    79       220     306749.0   1394.3      0.1              dhat_j = [state_i[StateVar_D_2] - 1, *state_i[StateVar_D_2:StateVar_D_M], 0]
    80       220     200508.0    911.4      0.1              hhat_j = [*state_i[StateVar_H_2:StateVar_H_M + 1], S_h_0]
    81                                                   else:
    82      4140    4510560.0   1089.5      1.6              dhat_j = [state_i[StateVar_D_1] - 1, *state_i[StateVar_D_2:StateVar_D_M + 1]]
    83      4140    3199447.0    772.8      1.2              hhat_j = [*state_i[StateVar_H_1:StateVar_H_M + 1]]
    84      4360    4206598.0    964.8      1.5          s = X - 1 - sum(dhat_j)
    85      4360    3173414.0    727.8      1.1          p_spawn = (s - (D_min - 1)) / (X - D_min)
    86      4360    5250141.0   1204.2      1.9          p_spawn = min(1, max(0, p_spawn))
    87      4360    2458120.0    563.8      0.9          p_no_spawn = 1 - p_spawn
    88      4360    2268497.0    520.3      0.8          m_min = M - 1
    89      6808    5053901.0    742.3      1.8          for m in range(1, M):
    90      4360    2622356.0    601.5      0.9              if dhat_j[m] == 0:
    91      1912     864588.0    452.2      0.3                  m_min = m
    92      1912     903233.0    472.4      0.3                  break
    93      4360    2091614.0    479.7      0.8          dspawn_j = None
    94      4360    2228980.0    511.2      0.8          if p_spawn > 0:
    95       940     630283.0    670.5      0.2              dspawn_j = dhat_j[:]
    96       940     514070.0    546.9      0.2              dspawn_j[m_min] = s
    97       940     727126.0    773.5      0.3              dspawn_j = tuple(dspawn_j)
    98       940     620980.0    660.6      0.2              hspawn_j = hhat_j[:]
    99                                           
   100      4360    3245279.0    744.3      1.2          dhat_tuple = tuple(dhat_j)
   101      4360    2711256.0    621.8      1.0          hhat_tuple = tuple(hhat_j)
   102                                           
   103                                                   # Each input will push to a seperate index in coo_*
   104                                                   # Important note: Duplicate entries will be SUMMED!
   105                                                   # This means that we do not have to worry about two inputs resulting in the same next_state (See += in compute_transition_probabilities)
   106     17440   10805640.0    619.6      3.9          for input_index, u_k, p_flap, W_v_list in U:
   107     34880   17829837.0    511.2      6.4              for w_v in W_v_list:
   108     21800   27496170.0   1261.3      9.9                  v_j = min(V_max, max(-V_max, state_i[StateVar_V] + u_k + w_v - g))
   109                                           
   110                                                           # Case 1: No spawn
   111     21800   11432872.0    524.4      4.1                  if p_no_spawn > 0:
   112     20540   15100849.0    735.2      5.4                      next_state = (y_j, v_j) + dhat_tuple + hhat_tuple
   113     20540   13188581.0    642.1      4.7                      j_index = state_to_index_dict[next_state]
   114                                           
   115     20540   13942596.0    678.8      5.0                      append_data[input_index](p_flap * p_no_spawn)
   116     20540   11925828.0    580.6      4.3                      append_rows[input_index](state_index)
   117     20540   11695404.0    569.4      4.2                      append_cols[input_index](j_index)
   118                                           
   119                                                           # Case 2: Spawn
   120     21800   11563599.0    530.4      4.2                  if p_spawn > 0:
   121      4700    3005912.0    639.6      1.1                      spawn_prefix = (y_j, v_j) + dspawn_j
   122      4700    2974002.0    632.8      1.1                      p_combined = p_flap * p_spawn * p_height
   123     14100    6999594.0    496.4      2.5                      for height in S_h:
   124      9400    4625320.0    492.1      1.7                          hspawn_j[m_min] = height
   125      9400    7015681.0    746.3      2.5                          next_state = spawn_prefix + tuple(hspawn_j)
   126      9400    6269271.0    666.9      2.3                          j_index = state_to_index_dict[next_state]
   127                                           
   128      9400    5670073.0    603.2      2.0                          append_data[input_index](p_combined)
   129      9400    5451143.0    579.9      2.0                          append_rows[input_index](state_index)
   130      9400    5834503.0    620.7      2.1                          append_cols[input_index](j_index)
   131                                           
   132                                               # Construct the sparse matrices
   133         4       2637.0    659.2      0.0      P_sparse_list = []
   134        16      60141.0   3758.8      0.0      for l in range(C.L):
   135                                                   # Build as COO first (fastest for this input)
   136        24   15689541.0 653730.9      5.7          P_l_coo = coo_matrix(
   137        12      11871.0    989.2      0.0              (coo_data[l], (coo_rows[l], coo_cols[l])),
   138        12       5852.0    487.7      0.0              shape=(K, K)
   139                                                   )
   140                                                   # Convert to CSC (fast, sums duplicates)
   141        12    3956577.0 329714.8      1.4          P_l = P_l_coo.tocsc()
   142        12      18986.0   1582.2      0.0          P_sparse_list.append(P_l)
   143                                           
   144         4       2146.0    536.5      0.0      return P_sparse_list

Total time: 0.752119 s
File: /home/gblum/dev/dpc/Solver.py
Function: solution_linear_prog_sparse at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                           def solution_linear_prog_sparse(C: Const) -> tuple[np.array, np.array]:
   112                                               """Computes the optimal cost and the optimal control policy.
   113                                           
   114                                               You can solve the SSP by any method:
   115                                               - Value Iteration
   116                                               - Policy Iteration
   117                                               - Linear Programming
   118                                               - A combination of the above
   119                                               - Others?
   120                                           
   121                                               Args:
   122                                                   C (Const): The constants describing the problem instance.
   123                                           
   124                                               Returns:
   125                                                   np.array: The optimal cost to go for the stochastic SPP,
   126                                                       of shape (C.K,), where C.K is the number of states.
   127                                                   np.array: The optimal control policy for the stochastic SPP,
   128                                                       of shape (C.K,), where each entry is in {0,...,C.L-1}.
   129                                               """
   130         4  147199586.0 3.68e+07     19.6      K, state_dict = custom_state_space(C)
   131                                           
   132         4      67486.0  16871.5      0.0      J_opt = np.zeros(K)
   133         4      12539.0   3134.8      0.0      u_opt = np.zeros(K)
   134                                           
   135         4  455552109.0 1.14e+08     60.6      P = compute_transition_probabilities(C, state_dict, K)
   136         4     798210.0 199552.5      0.1      Q, b = compute_expected_stage_cost(C, K)
   137                                           
   138         4     124226.0  31056.5      0.0      c = np.full(K, -1, np.int64)
   139                                           
   140                                               # 1. Create a sparse identity matrix
   141         4    1750337.0 437584.2      0.2      I_sparse = eye(K, format='csc')
   142                                           
   143                                               # 2. Create a list to hold the sparse blocks (I - P_l)
   144         4       4593.0   1148.2      0.0      A_blocks = []
   145                                           
   146                                               # 3. Loop over all actions
   147        16      86256.0   5391.0      0.0      for l in range(C.L):
   148                                                   # Add the sparse (I - P_l) block to our list
   149        12    6836614.0 569717.8      0.9          A_blocks.append(I_sparse - P[l])
   150                                           
   151                                               # 4. Stack all blocks vertically into one sparse matrix
   152         4    3603591.0 900897.8      0.5      A = vstack(A_blocks, format='csc')
   153                                           
   154                                               # 'highs' is the best for sparse problems
   155         4  134587956.0 3.36e+07     17.9      res = linprog(c, A_ub=A, b_ub=b, bounds=[None, 0], method='highs')
   156                                           
   157         4      45137.0  11284.2      0.0      J_opt = res.x
   158                                           
   159                                               # Create a list of weighted_J vectors, one for each action l
   160         4       3457.0    864.2      0.0      weighted_J_cols = []
   161        16      51354.0   3209.6      0.0      for l in range(C.L):
   162                                                   # P[l] is (K, K) sparse, J_opt is (K,) dense
   163                                                   # The @ operator performs efficient sparse-dot-dense
   164        12     758764.0  63230.3      0.1          weighted_J_l = P[l] @ J_opt  # Result is a (K,) dense vector
   165        12      16603.0   1383.6      0.0          weighted_J_cols.append(weighted_J_l)
   166                                           
   167                                               # Stack the (K,) vectors as columns into a (K, L) dense array
   168         4     241960.0  60490.0      0.0      weighted_J_all = np.stack(weighted_J_cols, axis=1)
   169         4     139423.0  34855.8      0.0      expected_values = Q + weighted_J_all
   170                                           
   171         4     175383.0  43845.8      0.0      optimal_indices = np.argmin(expected_values, axis=1)
   172         4      59794.0  14948.5      0.0      u_opt = np.array(C.input_space)[optimal_indices]
   173                                           
   174         4       3550.0    887.5      0.0      return J_opt, u_opt

  0.00 seconds - /home/gblum/dev/dpc/ComputeExpectedStageCosts.py:27 - compute_expected_stage_cost_solver
  0.08 seconds - /home/gblum/dev/dpc/utils.py:112 - custom_state_space.<locals>._build_d_recursive
  0.15 seconds - /home/gblum/dev/dpc/utils.py:83 - custom_state_space
  0.28 seconds - /home/gblum/dev/dpc/ComputeTransitionProbabilities.py:28 - compute_transition_probabilities_sparse
  0.75 seconds - /home/gblum/dev/dpc/Solver.py:111 - solution_linear_prog_sparse

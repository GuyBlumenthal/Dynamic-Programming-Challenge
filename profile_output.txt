Timer unit: 1e-09 s

Total time: 0.000220096 s
File: /home/gblum/dev/dpc/ComputeExpectedStageCosts.py
Function: compute_expected_stage_cost_solver at line 27

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    27                                           @profile
    28                                           def compute_expected_stage_cost_solver(C: Const, K: int) -> Tuple[np.array, np.array]:
    29         8      16387.0   2048.4      7.4      costs_row = np.array([
    30         4       1872.0    468.0      0.9          -1,                # Cost for action 0 (None)
    31         4       5067.0   1266.8      2.3          C.lam_weak - 1,    # Cost for action 1 (Weak)
    32         4       1809.0    452.2      0.8          C.lam_strong - 1   # Cost for action 2 (Strong)
    33                                               ])
    34                                           
    35         8      41629.0   5203.6     18.9      b = np.concatenate((
    36         4      74615.0  18653.8     33.9          np.repeat(costs_row[0], K),  # Column 0 of Q
    37         4      28352.0   7088.0     12.9          np.repeat(costs_row[1], K),  # Column 1 of Q
    38         4      23640.0   5910.0     10.7          np.repeat(costs_row[2], K)   # Column 2 of Q
    39                                               ))
    40                                           
    41         4      25363.0   6340.8     11.5      Q = b.reshape((K, C.L), order='F')
    42                                           
    43         4       1362.0    340.5      0.6      return Q, b

Total time: 0.0491733 s
File: /home/gblum/dev/dpc/utils.py
Function: custom_state_space.<locals>._build_d_recursive at line 112

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   112                                               @profile
   113                                               def _build_d_recursive(y, v, current_d_list, current_d_sum, d_index, zero_seen):
   114                                                   """
   115                                                   Recursively builds the D-vector (d1, ..., dM) for a given
   116                                                   (y, v) prefix.
   117                                           
   118                                                   Pruning:
   119                                                   - sum(d) > X-1
   120                                                   - Trailing zeros (if d_i=0, all d_j for j>i must be 0)
   121                                                   - d2=0 if d1=0
   122                                                   """
   123                                                   # --- Base Case: D-vector is complete ---
   124      3006    1440552.0    479.2      2.9          if d_index == M:
   125                                                       # D-vector is built, now start building the H-vector
   126                                                       nonlocal current_index
   127                                           
   128      1908    1042318.0    546.3      2.1              d_tuple = tuple(current_d_list)
   129                                           
   130                                                       # 1. Build the list of allowed H-options for this d_tuple
   131      1908     849411.0    445.2      1.7              h_iterables = [h_options_all] # h1 always has all options
   132                                           
   133      3816    2223644.0    582.7      4.5              for i in range(1, M): # For d2...dM
   134      1908     991961.0    519.9      2.0                  if d_tuple[i] == 0:
   135       846     507508.0    599.9      1.0                      h_iterables.append(h_options_default)
   136                                                           else:
   137      1062     626854.0    590.3      1.3                      h_iterables.append(h_options_all)
   138                                           
   139                                                       # 2. Loop over the product of these allowed H-options
   140      7848    4114825.0    524.3      8.4              for h_tuple in product(*h_iterables):
   141      5940    4345997.0    731.6      8.8                  state = (y, v, *d_tuple, *h_tuple)
   142      5940    3480751.0    586.0      7.1                  state_to_index_dict[state] = current_index
   143      5940    2659795.0    447.8      5.4                  current_index += 1
   144                                           
   145      1908     791549.0    414.9      1.6              return
   146                                           
   147                                                   # --- Recursive Step: Add d_i ---
   148      1098     489154.0    445.5      1.0          if d_index == 0:
   149       126      52632.0    417.7      0.1              d_options = S_d1
   150       972     374275.0    385.1      0.8          elif zero_seen:
   151                                                       d_options = S_d0
   152                                                   else:
   153       972     373234.0    384.0      0.8              d_options = S_d
   154                                           
   155      6570    2800895.0    426.3      5.7          for d in d_options:
   156                                                       # 1. Sum constraint
   157      5472    2727055.0    498.4      5.5              if current_d_sum + d > X_limit:
   158      2466     909069.0    368.6      1.8                  continue
   159                                           
   160                                                       # 3. d1/d2 constraint (d1=0 -> d2>0)
   161                                                       # d_index == 1 is d2
   162      3006    1332074.0    443.1      2.7              if d_index == 1:
   163      2034     909449.0    447.1      1.8                  d1 = current_d_list[0]
   164      2034     752278.0    369.9      1.5                  d2 = d
   165      2034     925037.0    454.8      1.9                  if d1 <= 0 and d2 == 0:
   166       126      46987.0    372.9      0.1                      continue
   167                                           
   168                                                       # Recurse with the added d
   169      2880    1322796.0    459.3      2.7              current_d_list[d_index] = d
   170      5760    7336420.0   1273.7     14.9              _build_d_recursive(
   171      2880    1050494.0    364.8      2.1                  y, v,
   172      2880     966736.0    335.7      2.0                  current_d_list,
   173      2880    1119513.0    388.7      2.3                  current_d_sum + d,
   174      2880    1198576.0    416.2      2.4                  d_index + 1,
   175                                                           # Update zero_seen flag:
   176                                                           # (zero_seen is True if it was already True, OR
   177                                                           # if we are adding a zero *after* d1)
   178      2880    1411493.0    490.1      2.9                  zero_seen or (d_index > 0 and d == 0)
   179                                                       )

Total time: 0.0945116 s
File: /home/gblum/dev/dpc/utils.py
Function: custom_state_space at line 83

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    83                                           @profile
    84                                           def custom_state_space(C: Const) -> Tuple[int, Dict[Tuple[int, ...], int]]:
    85                                               """
    86                                               Computes the state space and returns a state -> index dictionary
    87                                               using a recursive, pruning-based generation method.
    88                                           
    89                                               This function maintains the strict lexicographical ordering
    90                                               from the problem statement, ensuring the state-to-index
    91                                               mapping is identical to the original 'itertools.product' method,
    92                                               but is significantly faster by pruning invalid branches early.
    93                                               """
    94                                           
    95         4       4311.0   1077.8      0.0      state_to_index_dict = {}
    96         4       4143.0   1035.8      0.0      current_index = 0
    97                                           
    98                                               # --- Cache constants from C for minor speedup ---
    99         4      40820.0  10205.0      0.0      S_y, S_v = C.S_y, C.S_v
   100         4      28713.0   7178.2      0.0      S_d, S_d1 = C.S_d, C.S_d1
   101         4       6273.0   1568.2      0.0      S_h, S_h_default = C.S_h, C.S_h[0]
   102         4      18161.0   4540.2      0.0      M, X_limit = C.M, C.X - 1
   103                                           
   104                                               # Pre-build the two possible lists for H-options
   105         4       2314.0    578.5      0.0      h_options_all = S_h
   106         4       3640.0    910.0      0.0      h_options_default = [S_h_default]
   107                                           
   108                                               # Pre build an empty D-options list
   109         4       2689.0    672.2      0.0      S_d0 = [0]
   110                                           
   111                                               # ================== D-Vector Recursive Builder ==================
   112         8    2708315.0 338539.4      2.9      @profile
   113         8       9269.0   1158.6      0.0      def _build_d_recursive(y, v, current_d_list, current_d_sum, d_index, zero_seen):
   114                                                   """
   115                                                   Recursively builds the D-vector (d1, ..., dM) for a given
   116                                                   (y, v) prefix.
   117                                           
   118                                                   Pruning:
   119                                                   - sum(d) > X-1
   120                                                   - Trailing zeros (if d_i=0, all d_j for j>i must be 0)
   121                                                   - d2=0 if d1=0
   122                                                   """
   123                                                   # --- Base Case: D-vector is complete ---
   124                                                   if d_index == M:
   125                                                       # D-vector is built, now start building the H-vector
   126                                                       nonlocal current_index
   127                                           
   128                                                       d_tuple = tuple(current_d_list)
   129                                           
   130                                                       # 1. Build the list of allowed H-options for this d_tuple
   131                                                       h_iterables = [h_options_all] # h1 always has all options
   132                                           
   133                                                       for i in range(1, M): # For d2...dM
   134                                                           if d_tuple[i] == 0:
   135                                                               h_iterables.append(h_options_default)
   136                                                           else:
   137                                                               h_iterables.append(h_options_all)
   138                                           
   139                                                       # 2. Loop over the product of these allowed H-options
   140                                                       for h_tuple in product(*h_iterables):
   141                                                           state = (y, v, *d_tuple, *h_tuple)
   142                                                           state_to_index_dict[state] = current_index
   143                                                           current_index += 1
   144                                           
   145                                                       return
   146                                           
   147                                                   # --- Recursive Step: Add d_i ---
   148                                                   if d_index == 0:
   149                                                       d_options = S_d1
   150                                                   elif zero_seen:
   151                                                       d_options = S_d0
   152                                                   else:
   153                                                       d_options = S_d
   154                                           
   155                                                   for d in d_options:
   156                                                       # 1. Sum constraint
   157                                                       if current_d_sum + d > X_limit:
   158                                                           continue
   159                                           
   160                                                       # 3. d1/d2 constraint (d1=0 -> d2>0)
   161                                                       # d_index == 1 is d2
   162                                                       if d_index == 1:
   163                                                           d1 = current_d_list[0]
   164                                                           d2 = d
   165                                                           if d1 <= 0 and d2 == 0:
   166                                                               continue
   167                                           
   168                                                       # Recurse with the added d
   169                                                       current_d_list[d_index] = d
   170                                                       _build_d_recursive(
   171                                                           y, v,
   172                                                           current_d_list,
   173                                                           current_d_sum + d,
   174                                                           d_index + 1,
   175                                                           # Update zero_seen flag:
   176                                                           # (zero_seen is True if it was already True, OR
   177                                                           # if we are adding a zero *after* d1)
   178                                                           zero_seen or (d_index > 0 and d == 0)
   179                                                       )
   180                                           
   181                                               # The outer loops *must* be y, then v, to maintain order
   182        34      17399.0    511.7      0.0      for y in S_y:
   183       156      76547.0    490.7      0.1          for v in S_v:
   184       126     107592.0    853.9      0.1              current_d_list_for_v = [0] * M
   185                                                       # Start the recursion for the D-vector
   186       126   91472789.0 725974.5     96.8              _build_d_recursive(y, v, current_d_list_for_v, 0, 0, False)
   187                                           
   188         4       8671.0   2167.8      0.0      return len(state_to_index_dict), state_to_index_dict

Total time: 0.155271 s
File: /home/gblum/dev/dpc/ComputeTransitionProbabilities.py
Function: compute_transition_probabilities_sparse at line 28

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    28                                           @profile
    29                                           def compute_transition_probabilities_sparse(C:Const, state_to_index_dict, K) -> list:
    30                                               """Computes the transition probability matrix P as a list of sparse matrices."""
    31                                           
    32                                               # Each action in C.input_space will have its own sparse probability matrix
    33         4      21481.0   5370.2      0.0      num_inputs = len(C.input_space)
    34                                           
    35                                               # A calculated probability P[curr_state, next_state, action] is stored as
    36                                               #   coo_data[action] = P[curr_state, next_state, action]
    37                                               #   coo_cols[action] = curr_state
    38                                               #   coo_rows[action] = next_state
    39         4      19234.0   4808.5      0.0      coo_data = [[] for input_i in range(num_inputs)]
    40         4      12526.0   3131.5      0.0      coo_cols = [[] for input_i in range(num_inputs)]
    41         4      11571.0   2892.8      0.0      coo_rows = [[] for input_i in range(num_inputs)]
    42                                           
    43                                               # Helper functions for populating coo table
    44         4      15280.0   3820.0      0.0      append_data = [l.append for l in coo_data]
    45         4      11050.0   2762.5      0.0      append_rows = [l.append for l in coo_rows]
    46         4      10552.0   2638.0      0.0      append_cols = [l.append for l in coo_cols]
    47                                           
    48                                               # Store variables once instead of recalculating
    49         4       4105.0   1026.2      0.0      Y_limit = C.Y - 1
    50         4       8349.0   2087.2      0.0      G_limit = (C.G - 1) / 2
    51         4      18628.0   4657.0      0.0      M = C.M
    52         4       2500.0    625.0      0.0      X, D_min = C.X, C.D_min
    53         4       4375.0   1093.8      0.0      V_max, g = C.V_max, C.g
    54         4       3523.0    880.8      0.0      S_h, S_h_0 = C.S_h, C.S_h[0]
    55         4       3715.0    928.8      0.0      p_height = 1 / len(S_h)
    56         4       4580.0   1145.0      0.0      U_strong_prob = 1 / (2 * C.V_dev + 1)
    57         4      20546.0   5136.5      0.0      W_v = C.W_v
    58                                           
    59         4       3035.0    758.8      0.0      StateVar_Y = 0
    60         4       1714.0    428.5      0.0      StateVar_V = 1
    61         4       1760.0    440.0      0.0      StateVar_D_1 = 2
    62         4       3099.0    774.8      0.0      StateVar_D_2 = StateVar_D_1 + 1
    63         4       2528.0    632.0      0.0      StateVar_D_M = StateVar_D_1 + M - 1
    64         4       1653.0    413.2      0.0      StateVar_H_1 = StateVar_D_M + 1
    65         4       1497.0    374.2      0.0      StateVar_H_2 = StateVar_H_1 + 1
    66         4       1591.0    397.8      0.0      StateVar_H_M = StateVar_H_1 + M - 1
    67                                           
    68         4       2487.0    621.8      0.0      U = [
    69         4       3513.0    878.2      0.0          [0, C.U_no_flap, 1, [0]],
    70         4       3916.0    979.0      0.0          [1, C.U_weak, 1, [0]],
    71         4       2264.0    566.0      0.0          [2, C.U_strong, U_strong_prob, W_v]
    72                                               ]
    73                                           
    74      5944    2432320.0    409.2      1.6      for state_i, state_index in state_to_index_dict.items():
    75      5940    3949182.0    664.8      2.5          y_j = min(Y_limit, max(0, state_i[StateVar_Y] + state_i[StateVar_V]))
    76      5940    2005656.0    337.7      1.3          if state_i[StateVar_D_1] == 0:
    77      1800     874810.0    486.0      0.6              if abs(state_i[StateVar_Y] - state_i[StateVar_H_1]) > G_limit:
    78      1580     383142.0    242.5      0.2                  continue
    79       220     134932.0    613.3      0.1              dhat_j = [state_i[StateVar_D_2] - 1, *state_i[StateVar_D_2:StateVar_D_M], 0]
    80       220     136384.0    619.9      0.1              hhat_j = [*state_i[StateVar_H_2:StateVar_H_M + 1], S_h_0]
    81                                                   else:
    82      4140    2310880.0    558.2      1.5              dhat_j = [state_i[StateVar_D_1] - 1, *state_i[StateVar_D_2:StateVar_D_M + 1]]
    83      4140    1694838.0    409.4      1.1              hhat_j = [*state_i[StateVar_H_1:StateVar_H_M + 1]]
    84      4360    2206460.0    506.1      1.4          s = X - 1 - sum(dhat_j)
    85      4360    1711612.0    392.6      1.1          p_spawn = (s - (D_min - 1)) / (X - D_min)
    86      4360    2613521.0    599.4      1.7          p_spawn = min(1, max(0, p_spawn))
    87      4360    1288178.0    295.5      0.8          p_no_spawn = 1 - p_spawn
    88      4360    1331777.0    305.5      0.9          m_min = M - 1
    89      6808    2746845.0    403.5      1.8          for m in range(1, M):
    90      4360    1468616.0    336.8      0.9              if dhat_j[m] == 0:
    91      1912     487896.0    255.2      0.3                  m_min = m
    92      1912     491511.0    257.1      0.3                  break
    93      4360    1249235.0    286.5      0.8          dspawn_j = None
    94      4360    1288592.0    295.5      0.8          if p_spawn > 0:
    95       940     345001.0    367.0      0.2              dspawn_j = dhat_j[:]
    96       940     283827.0    301.9      0.2              dspawn_j[m_min] = s
    97       940     350468.0    372.8      0.2              hspawn_j = hhat_j[:]
    98                                           
    99                                                   # Each input will push to a seperate index in coo_*
   100                                                   # Important note: Duplicate entries will be SUMMED!
   101                                                   # This means that we do not have to worry about two inputs resulting in the same next_state (See += in compute_transition_probabilities)
   102     17440    6947780.0    398.4      4.5          for input_index, u_k, p_flap, W_v_list in U:
   103     34880    9966260.0    285.7      6.4              for w_v in W_v_list:
   104     21800   14995749.0    687.9      9.7                  v_j = min(V_max, max(-V_max, state_i[StateVar_V] + u_k + w_v - g))
   105                                           
   106                                                           # Case 1: No spawn
   107     21800    6458374.0    296.3      4.2                  if p_no_spawn > 0:
   108     20540    9134087.0    444.7      5.9                      next_state = (y_j, v_j, *dhat_j, *hhat_j)
   109     20540    7469845.0    363.7      4.8                      j_index = state_to_index_dict[next_state]
   110                                           
   111     20540    7864751.0    382.9      5.1                      append_data[input_index](p_flap * p_no_spawn)
   112     20540    6704084.0    326.4      4.3                      append_rows[input_index](state_index)
   113     20540    6608067.0    321.7      4.3                      append_cols[input_index](j_index)
   114                                           
   115                                                           # Case 2: Spawn
   116     21800    6661321.0    305.6      4.3                  if p_spawn > 0:
   117      4700    1594727.0    339.3      1.0                      p_combined = p_flap * p_spawn * p_height
   118     14100    3893933.0    276.2      2.5                      for height in S_h:
   119      9400    2537631.0    270.0      1.6                          hspawn_j[m_min] = height
   120      9400    3836555.0    408.1      2.5                          next_state = (y_j, v_j, *dspawn_j, *hspawn_j)
   121      9400    3473348.0    369.5      2.2                          j_index = state_to_index_dict[next_state]
   122                                           
   123      9400    3079788.0    327.6      2.0                          append_data[input_index](p_combined)
   124      9400    3003463.0    319.5      1.9                          append_rows[input_index](state_index)
   125      9400    3160143.0    336.2      2.0                          append_cols[input_index](j_index)
   126                                           
   127                                               # Construct the sparse matrices
   128         4       2673.0    668.2      0.0      P_sparse_list = []
   129        16      51342.0   3208.9      0.0      for l in range(C.L):
   130        24   15802009.0 658417.0     10.2          P_l = sparse_matrix(
   131        12      12605.0   1050.4      0.0              (coo_data[l], (coo_rows[l], coo_cols[l])),
   132        12       5180.0    431.7      0.0              shape=(K, K)
   133                                                   )
   134        12      19060.0   1588.3      0.0          P_sparse_list.append(P_l)
   135                                           
   136         4       1162.0    290.5      0.0      return P_sparse_list

Total time: 0.429084 s
File: /home/gblum/dev/dpc/Solver.py
Function: solution_linear_prog_sparse at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                           def solution_linear_prog_sparse(C: Const) -> tuple[np.array, np.array]:
   112                                               """Computes the optimal cost and the optimal control policy.
   113                                           
   114                                               You can solve the SSP by any method:
   115                                               - Value Iteration
   116                                               - Policy Iteration
   117                                               - Linear Programming
   118                                               - A combination of the above
   119                                               - Others?
   120                                           
   121                                               Args:
   122                                                   C (Const): The constants describing the problem instance.
   123                                           
   124                                               Returns:
   125                                                   np.array: The optimal cost to go for the stochastic SPP,
   126                                                       of shape (C.K,), where C.K is the number of states.
   127                                                   np.array: The optimal control policy for the stochastic SPP,
   128                                                       of shape (C.K,), where each entry is in {0,...,C.L-1}.
   129                                               """
   130         4   94808545.0 2.37e+07     22.1      K, state_dict = custom_state_space(C)
   131                                           
   132         4      46574.0  11643.5      0.0      J_opt = np.zeros(K)
   133         4       8481.0   2120.2      0.0      u_opt = np.zeros(K)
   134                                           
   135         4  250572017.0 6.26e+07     58.4      P = compute_transition_probabilities(C, state_dict, K)
   136         4     306960.0  76740.0      0.1      Q, b = compute_expected_stage_cost(C, K)
   137                                           
   138         4      49490.0  12372.5      0.0      c = np.full(K, -1, np.int64)
   139                                           
   140                                               # 1. Create a sparse identity matrix
   141         4     525925.0 131481.2      0.1      I_sparse = eye(K, format='csc')
   142                                           
   143                                               # 2. Create a list to hold the sparse blocks (I - P_l)
   144         4       2181.0    545.2      0.0      A_blocks = []
   145                                           
   146                                               # 3. Loop over all actions
   147        16      18917.0   1182.3      0.0      for l in range(C.L):
   148                                                   # Add the sparse (I - P_l) block to our list
   149        12    2892154.0 241012.8      0.7          A_blocks.append(I_sparse - P[l])
   150                                           
   151                                               # 4. Stack all blocks vertically into one sparse matrix
   152         4    1645706.0 411426.5      0.4      A = vstack(A_blocks, format='csc')
   153                                           
   154                                               # 'highs' is the best for sparse problems
   155         4   77375984.0 1.93e+07     18.0      res = linprog(c, A_ub=A, b_ub=b, bounds=[None, 0], method='highs')
   156                                           
   157         4      23550.0   5887.5      0.0      J_opt = res.x
   158                                           
   159                                               # Create a list of weighted_J vectors, one for each action l
   160         4       1739.0    434.8      0.0      weighted_J_cols = []
   161        16      27696.0   1731.0      0.0      for l in range(C.L):
   162                                                   # P[l] is (K, K) sparse, J_opt is (K,) dense
   163                                                   # The @ operator performs efficient sparse-dot-dense
   164        12     377050.0  31420.8      0.1          weighted_J_l = P[l] @ J_opt  # Result is a (K,) dense vector
   165        12       7540.0    628.3      0.0          weighted_J_cols.append(weighted_J_l)
   166                                           
   167                                               # Stack the (K,) vectors as columns into a (K, L) dense array
   168         4     176874.0  44218.5      0.0      weighted_J_all = np.stack(weighted_J_cols, axis=1)
   169         4      98392.0  24598.0      0.0      expected_values = Q + weighted_J_all
   170                                           
   171         4      88561.0  22140.2      0.0      optimal_indices = np.argmin(expected_values, axis=1)
   172         4      28781.0   7195.2      0.0      u_opt = np.array(C.input_space)[optimal_indices]
   173                                           
   174         4       1367.0    341.8      0.0      return J_opt, u_opt

  0.00 seconds - /home/gblum/dev/dpc/ComputeExpectedStageCosts.py:27 - compute_expected_stage_cost_solver
  0.05 seconds - /home/gblum/dev/dpc/utils.py:112 - custom_state_space.<locals>._build_d_recursive
  0.09 seconds - /home/gblum/dev/dpc/utils.py:83 - custom_state_space
  0.16 seconds - /home/gblum/dev/dpc/ComputeTransitionProbabilities.py:28 - compute_transition_probabilities_sparse
  0.43 seconds - /home/gblum/dev/dpc/Solver.py:111 - solution_linear_prog_sparse

Timer unit: 1e-09 s

Total time: 0.000205612 s
File: /home/gblum/dev/dpc/ComputeExpectedStageCosts.py
Function: compute_expected_stage_cost_solver at line 27

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    27                                           @profile
    28                                           def compute_expected_stage_cost_solver(C: Const, K: int) -> Tuple[np.array, np.array]:
    29         8      18777.0   2347.1      9.1      costs_row = np.array([
    30         4       1960.0    490.0      1.0          -1,                # Cost for action 0 (None)
    31         4       5524.0   1381.0      2.7          C.lam_weak - 1,    # Cost for action 1 (Weak)
    32         4       1755.0    438.8      0.9          C.lam_strong - 1   # Cost for action 2 (Strong)
    33                                               ])
    34                                           
    35         8      37666.0   4708.2     18.3      b = np.concatenate((
    36         4      68906.0  17226.5     33.5          np.repeat(costs_row[0], K),  # Column 0 of Q
    37         4      24737.0   6184.2     12.0          np.repeat(costs_row[1], K),  # Column 1 of Q
    38         4      20570.0   5142.5     10.0          np.repeat(costs_row[2], K)   # Column 2 of Q
    39                                               ))
    40                                           
    41         4      24405.0   6101.2     11.9      Q = b.reshape((K, C.L), order='F')
    42                                           
    43         4       1312.0    328.0      0.6      return Q, b

Total time: 0.0494219 s
File: /home/gblum/dev/dpc/utils.py
Function: custom_state_space.<locals>._build_d_recursive at line 112

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   112                                               @profile
   113                                               def _build_d_recursive(y, v, current_d_list, current_d_sum, d_index, zero_seen):
   114                                                   """
   115                                                   Recursively builds the D-vector (d1, ..., dM) for a given
   116                                                   (y, v) prefix.
   117                                           
   118                                                   Pruning:
   119                                                   - sum(d) > X-1
   120                                                   - Trailing zeros (if d_i=0, all d_j for j>i must be 0)
   121                                                   - d2=0 if d1=0
   122                                                   """
   123                                                   # --- Base Case: D-vector is complete ---
   124      3006    1225560.0    407.7      2.5          if d_index == M:
   125                                                       # D-vector is built, now start building the H-vector
   126                                                       nonlocal current_index
   127                                           
   128      1908     984944.0    516.2      2.0              d_tuple = tuple(current_d_list)
   129                                           
   130                                                       # 1. Build the list of allowed H-options for this d_tuple
   131      1908     800695.0    419.7      1.6              h_iterables = [h_options_all] # h1 always has all options
   132                                           
   133      3816    2174868.0    569.9      4.4              for i in range(1, M): # For d2...dM
   134      1908     902837.0    473.2      1.8                  if d_tuple[i] == 0:
   135       846     482614.0    570.5      1.0                      h_iterables.append(h_options_default)
   136                                                           else:
   137      1062     606222.0    570.8      1.2                      h_iterables.append(h_options_all)
   138                                           
   139                                                       # 2. Loop over the product of these allowed H-options
   140      7848    3976723.0    506.7      8.0              for h_tuple in product(*h_iterables):
   141      5940    4582771.0    771.5      9.3                  state = (y, v, *d_tuple, *h_tuple)
   142      5940    3332713.0    561.1      6.7                  state_to_index_dict[state] = current_index
   143      5940    2671264.0    449.7      5.4                  current_index += 1
   144                                           
   145      1908     717639.0    376.1      1.5              return
   146                                           
   147                                                   # --- Recursive Step: Add d_i ---
   148      1098     465001.0    423.5      0.9          if d_index == 0:
   149       126      51790.0    411.0      0.1              d_options = S_d1
   150       972     333607.0    343.2      0.7          elif zero_seen:
   151                                                       d_options = S_d0
   152                                                   else:
   153       972     358810.0    369.1      0.7              d_options = S_d
   154                                           
   155      6570    2832594.0    431.1      5.7          for d in d_options:
   156                                                       # 1. Sum constraint
   157      5472    2575172.0    470.6      5.2              if current_d_sum + d > X_limit:
   158      2466     851542.0    345.3      1.7                  continue
   159                                           
   160                                                       # 3. d1/d2 constraint (d1=0 -> d2>0)
   161                                                       # d_index == 1 is d2
   162      3006    1225454.0    407.7      2.5              if d_index == 1:
   163      2034     858592.0    422.1      1.7                  d1 = current_d_list[0]
   164      2034     734229.0    361.0      1.5                  d2 = d
   165      2034     841360.0    413.6      1.7                  if d1 <= 0 and d2 == 0:
   166       126      42574.0    337.9      0.1                      continue
   167                                           
   168                                                       # Recurse with the added d and pop after completing the branch
   169      2880    1640124.0    569.5      3.3              current_d_list.append(d)
   170      5760    6923725.0   1202.0     14.0              _build_d_recursive(
   171      2880    1015513.0    352.6      2.1                  y, v,
   172      2880     937763.0    325.6      1.9                  current_d_list,
   173      2880    1075503.0    373.4      2.2                  current_d_sum + d,
   174      2880    1125613.0    390.8      2.3                  d_index + 1,
   175                                                           # Update zero_seen flag:
   176                                                           # (zero_seen is True if it was already True, OR
   177                                                           # if we are adding a zero *after* d1)
   178      2880    1334273.0    463.3      2.7                  zero_seen or (d_index > 0 and d == 0)
   179                                                       )
   180      2880    1739840.0    604.1      3.5              current_d_list.pop() # Backtrack

Total time: 0.0954463 s
File: /home/gblum/dev/dpc/utils.py
Function: custom_state_space at line 83

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    83                                           @profile
    84                                           def custom_state_space(C: Const) -> Tuple[int, Dict[Tuple[int, ...], int]]:
    85                                               """
    86                                               Computes the state space and returns a state -> index dictionary
    87                                               using a recursive, pruning-based generation method.
    88                                           
    89                                               This function maintains the strict lexicographical ordering
    90                                               from the problem statement, ensuring the state-to-index
    91                                               mapping is identical to the original 'itertools.product' method,
    92                                               but is significantly faster by pruning invalid branches early.
    93                                               """
    94                                           
    95         4       3946.0    986.5      0.0      state_to_index_dict = {}
    96         4       4643.0   1160.8      0.0      current_index = 0
    97                                           
    98                                               # --- Cache constants from C for minor speedup ---
    99         4      40834.0  10208.5      0.0      S_y, S_v = C.S_y, C.S_v
   100         4      27183.0   6795.8      0.0      S_d, S_d1 = C.S_d, C.S_d1
   101         4       6373.0   1593.2      0.0      S_h, S_h_default = C.S_h, C.S_h[0]
   102         4      18669.0   4667.2      0.0      M, X_limit = C.M, C.X - 1
   103                                           
   104                                               # Pre-build the two possible lists for H-options
   105         4       2816.0    704.0      0.0      h_options_all = S_h
   106         4       2432.0    608.0      0.0      h_options_default = [S_h_default]
   107                                           
   108                                               # Pre build an empty D-options list
   109         4       2656.0    664.0      0.0      S_d0 = [0]
   110                                           
   111                                               # ================== D-Vector Recursive Builder ==================
   112         8    2548359.0 318544.9      2.7      @profile
   113         8       8723.0   1090.4      0.0      def _build_d_recursive(y, v, current_d_list, current_d_sum, d_index, zero_seen):
   114                                                   """
   115                                                   Recursively builds the D-vector (d1, ..., dM) for a given
   116                                                   (y, v) prefix.
   117                                           
   118                                                   Pruning:
   119                                                   - sum(d) > X-1
   120                                                   - Trailing zeros (if d_i=0, all d_j for j>i must be 0)
   121                                                   - d2=0 if d1=0
   122                                                   """
   123                                                   # --- Base Case: D-vector is complete ---
   124                                                   if d_index == M:
   125                                                       # D-vector is built, now start building the H-vector
   126                                                       nonlocal current_index
   127                                           
   128                                                       d_tuple = tuple(current_d_list)
   129                                           
   130                                                       # 1. Build the list of allowed H-options for this d_tuple
   131                                                       h_iterables = [h_options_all] # h1 always has all options
   132                                           
   133                                                       for i in range(1, M): # For d2...dM
   134                                                           if d_tuple[i] == 0:
   135                                                               h_iterables.append(h_options_default)
   136                                                           else:
   137                                                               h_iterables.append(h_options_all)
   138                                           
   139                                                       # 2. Loop over the product of these allowed H-options
   140                                                       for h_tuple in product(*h_iterables):
   141                                                           state = (y, v, *d_tuple, *h_tuple)
   142                                                           state_to_index_dict[state] = current_index
   143                                                           current_index += 1
   144                                           
   145                                                       return
   146                                           
   147                                                   # --- Recursive Step: Add d_i ---
   148                                                   if d_index == 0:
   149                                                       d_options = S_d1
   150                                                   elif zero_seen:
   151                                                       d_options = S_d0
   152                                                   else:
   153                                                       d_options = S_d
   154                                           
   155                                                   for d in d_options:
   156                                                       # 1. Sum constraint
   157                                                       if current_d_sum + d > X_limit:
   158                                                           continue
   159                                           
   160                                                       # 3. d1/d2 constraint (d1=0 -> d2>0)
   161                                                       # d_index == 1 is d2
   162                                                       if d_index == 1:
   163                                                           d1 = current_d_list[0]
   164                                                           d2 = d
   165                                                           if d1 <= 0 and d2 == 0:
   166                                                               continue
   167                                           
   168                                                       # Recurse with the added d and pop after completing the branch
   169                                                       current_d_list.append(d)
   170                                                       _build_d_recursive(
   171                                                           y, v,
   172                                                           current_d_list,
   173                                                           current_d_sum + d,
   174                                                           d_index + 1,
   175                                                           # Update zero_seen flag:
   176                                                           # (zero_seen is True if it was already True, OR
   177                                                           # if we are adding a zero *after* d1)
   178                                                           zero_seen or (d_index > 0 and d == 0)
   179                                                       )
   180                                                       current_d_list.pop() # Backtrack
   181                                           
   182                                               # The outer loops *must* be y, then v, to maintain order
   183        34      19425.0    571.3      0.0      for y in S_y:
   184       156      76989.0    493.5      0.1          for v in S_v:
   185                                                       # Start the recursion for the D-vector
   186       126   92675893.0 735523.0     97.1              _build_d_recursive(y, v, [], 0, 0, False)
   187                                           
   188         4       7325.0   1831.2      0.0      return len(state_to_index_dict), state_to_index_dict

Total time: 0.153248 s
File: /home/gblum/dev/dpc/ComputeTransitionProbabilities.py
Function: compute_transition_probabilities_sparse at line 29

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    29                                           @profile
    30                                           def compute_transition_probabilities_sparse(C:Const, state_to_index_dict, K) -> list:
    31                                               """Computes the transition probability matrix P as a list of sparse matrices."""
    32                                           
    33                                               # Each action in C.input_space will have its own sparse probability matrix
    34         4      18913.0   4728.2      0.0      num_inputs = len(C.input_space)
    35                                           
    36                                               # A calculated probability P[curr_state, next_state, action] is stored as
    37                                               #   coo_data[action] = P[curr_state, next_state, action]
    38                                               #   coo_cols[action] = curr_state
    39                                               #   coo_rows[action] = next_state
    40         4      19511.0   4877.8      0.0      coo_data = [[] for input_i in range(num_inputs)]
    41         4      10856.0   2714.0      0.0      coo_cols = [[] for input_i in range(num_inputs)]
    42         4      14971.0   3742.8      0.0      coo_rows = [[] for input_i in range(num_inputs)]
    43                                           
    44                                               # Helper functions for populating coo table
    45         4      25545.0   6386.2      0.0      append_data = [l.append for l in coo_data]
    46         4      18911.0   4727.8      0.0      append_rows = [l.append for l in coo_rows]
    47         4       9317.0   2329.2      0.0      append_cols = [l.append for l in coo_cols]
    48                                           
    49                                               # Store variables once instead of recalculating
    50         4       4658.0   1164.5      0.0      Y_limit = C.Y - 1
    51         4       6287.0   1571.8      0.0      G_limit = (C.G - 1) / 2
    52         4      18203.0   4550.8      0.0      M = C.M
    53         4       2176.0    544.0      0.0      X, D_min = C.X, C.D_min
    54         4       2511.0    627.8      0.0      V_max, g = C.V_max, C.g
    55         4       3836.0    959.0      0.0      S_h, S_h_0 = C.S_h, C.S_h[0]
    56         4       4244.0   1061.0      0.0      p_height = 1 / len(S_h)
    57         4       4578.0   1144.5      0.0      U_strong_prob = 1 / (2 * C.V_dev + 1)
    58         4      17948.0   4487.0      0.0      W_v = C.W_v
    59                                           
    60         4       2149.0    537.2      0.0      StateVar_Y = 0
    61         4       1591.0    397.8      0.0      StateVar_V = 1
    62         4       1652.0    413.0      0.0      StateVar_D_1 = 2
    63         4       2655.0    663.8      0.0      StateVar_D_2 = StateVar_D_1 + 1
    64         4       2376.0    594.0      0.0      StateVar_D_M = StateVar_D_1 + M - 1
    65         4       1738.0    434.5      0.0      StateVar_H_1 = StateVar_D_M + 1
    66         4       1185.0    296.2      0.0      StateVar_H_2 = StateVar_H_1 + 1
    67         4       1975.0    493.8      0.0      StateVar_H_M = StateVar_H_1 + M - 1
    68                                           
    69         4       2234.0    558.5      0.0      U = [
    70         4       3432.0    858.0      0.0          [0, C.U_no_flap, 1, [0]],
    71         4       2792.0    698.0      0.0          [1, C.U_weak, 1, [0]],
    72         4       2726.0    681.5      0.0          [2, C.U_strong, U_strong_prob, W_v]
    73                                               ]
    74                                           
    75      5944    2048643.0    344.7      1.3      for state_i, state_index in state_to_index_dict.items():
    76      5940    3948102.0    664.7      2.6          y_j = min(Y_limit, max(0, state_i[StateVar_Y] + state_i[StateVar_V]))
    77      5940    1961626.0    330.2      1.3          if state_i[StateVar_D_1] == 0:
    78      1800     859190.0    477.3      0.6              if abs(state_i[StateVar_Y] - state_i[StateVar_H_1]) > G_limit:
    79      1580     361756.0    229.0      0.2                  continue
    80       220     138668.0    630.3      0.1              dhat_j = [state_i[StateVar_D_2] - 1, *state_i[StateVar_D_2:StateVar_D_M], 0]
    81       220     120475.0    547.6      0.1              hhat_j = [*state_i[StateVar_H_2:StateVar_H_M + 1], S_h_0]
    82                                                   else:
    83      4140    2176984.0    525.8      1.4              dhat_j = [state_i[StateVar_D_1] - 1, *state_i[StateVar_D_2:StateVar_D_M + 1]]
    84      4140    1831145.0    442.3      1.2              hhat_j = [*state_i[StateVar_H_1:StateVar_H_M + 1]]
    85      4360    2088319.0    479.0      1.4          s = X - 1 - sum(dhat_j)
    86      4360    1684010.0    386.2      1.1          p_spawn = (s - (D_min - 1)) / (X - D_min)
    87      4360    2750107.0    630.8      1.8          p_spawn = min(1, max(0, p_spawn))
    88      4360    1319002.0    302.5      0.9          p_no_spawn = 1 - p_spawn
    89      4360    1333415.0    305.8      0.9          m_min = M - 1
    90      6808    2751191.0    404.1      1.8          for m in range(1, M):
    91      4360    1411101.0    323.6      0.9              if dhat_j[m] == 0:
    92      1912     482628.0    252.4      0.3                  m_min = m
    93      1912     505206.0    264.2      0.3                  break
    94      4360    1193967.0    273.8      0.8          dspawn_j = None
    95      4360    1227399.0    281.5      0.8          if p_spawn > 0:
    96       940    1568161.0   1668.3      1.0              dspawn_j = copy(dhat_j)
    97       940     281128.0    299.1      0.2              dspawn_j[m_min] = s
    98       940    1318472.0   1402.6      0.9              hspawn_j = copy(hhat_j)
    99                                           
   100                                                   # Each input will push to a seperate index in coo_*
   101                                                   # Important note: Duplicate entries will be SUMMED!
   102                                                   # This means that we do not have to worry about two inputs resulting in the same next_state (See += in compute_transition_probabilities)
   103     17440    6110127.0    350.4      4.0          for input_index, u_k, p_flap, W_v_list in U:
   104     34880    9795500.0    280.8      6.4              for w_v in W_v_list:
   105     21800   14995018.0    687.8      9.8                  v_j = min(V_max, max(-V_max, state_i[StateVar_V] + u_k + w_v - g))
   106                                           
   107                                                           # Case 1: No spawn
   108     21800    6038972.0    277.0      3.9                  if p_no_spawn > 0:
   109     20540    8562455.0    416.9      5.6                      next_state = (y_j, v_j, *dhat_j, *hhat_j)
   110     20540    7358675.0    358.3      4.8                      j_index = state_to_index_dict[next_state]
   111                                           
   112     20540    7760034.0    377.8      5.1                      append_data[input_index](p_flap * p_no_spawn)
   113     20540    6577291.0    320.2      4.3                      append_rows[input_index](state_index)
   114     20540    6336327.0    308.5      4.1                      append_cols[input_index](j_index)
   115                                           
   116                                                           # Case 2: Spawn
   117     21800    6447115.0    295.7      4.2                  if p_spawn > 0:
   118      4700    1620318.0    344.7      1.1                      p_combined = p_flap * p_spawn * p_height
   119     14100    3743112.0    265.5      2.4                      for height in S_h:
   120      9400    2492014.0    265.1      1.6                          hspawn_j[m_min] = height
   121      9400    3845459.0    409.1      2.5                          next_state = (y_j, v_j, *dspawn_j, *hspawn_j)
   122      9400    3394967.0    361.2      2.2                          j_index = state_to_index_dict[next_state]
   123                                           
   124      9400    3070299.0    326.6      2.0                          append_data[input_index](p_combined)
   125      9400    2908239.0    309.4      1.9                          append_rows[input_index](state_index)
   126      9400    3121675.0    332.1      2.0                          append_cols[input_index](j_index)
   127                                           
   128                                               # Construct the sparse matrices
   129         4       1945.0    486.2      0.0      P_sparse_list = []
   130        16      35893.0   2243.3      0.0      for l in range(C.L):
   131        24   15435362.0 643140.1     10.1          P_l = sparse_matrix(
   132        12       9484.0    790.3      0.0              (coo_data[l], (coo_rows[l], coo_cols[l])),
   133        12       4050.0    337.5      0.0              shape=(K, K)
   134                                                   )
   135        12      13117.0   1093.1      0.0          P_sparse_list.append(P_l)
   136                                           
   137         4       1131.0    282.8      0.0      return P_sparse_list

Total time: 0.429378 s
File: /home/gblum/dev/dpc/Solver.py
Function: solution_linear_prog_sparse at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                           def solution_linear_prog_sparse(C: Const) -> tuple[np.array, np.array]:
   112                                               """Computes the optimal cost and the optimal control policy.
   113                                           
   114                                               You can solve the SSP by any method:
   115                                               - Value Iteration
   116                                               - Policy Iteration
   117                                               - Linear Programming
   118                                               - A combination of the above
   119                                               - Others?
   120                                           
   121                                               Args:
   122                                                   C (Const): The constants describing the problem instance.
   123                                           
   124                                               Returns:
   125                                                   np.array: The optimal cost to go for the stochastic SPP,
   126                                                       of shape (C.K,), where C.K is the number of states.
   127                                                   np.array: The optimal control policy for the stochastic SPP,
   128                                                       of shape (C.K,), where each entry is in {0,...,C.L-1}.
   129                                               """
   130         4   95690476.0 2.39e+07     22.3      K, state_dict = custom_state_space(C)
   131                                           
   132         4      43450.0  10862.5      0.0      J_opt = np.zeros(K)
   133         4       8154.0   2038.5      0.0      u_opt = np.zeros(K)
   134                                           
   135         4  247470321.0 6.19e+07     57.6      P = compute_transition_probabilities(C, state_dict, K)
   136         4     259762.0  64940.5      0.1      Q, b = compute_expected_stage_cost(C, K)
   137                                           
   138         4      41461.0  10365.2      0.0      c = np.full(K, -1, np.int64)
   139                                           
   140                                               # 1. Create a sparse identity matrix
   141         4     533815.0 133453.8      0.1      I_sparse = eye(K, format='csc')
   142                                           
   143                                               # 2. Create a list to hold the sparse blocks (I - P_l)
   144         4       1762.0    440.5      0.0      A_blocks = []
   145                                           
   146                                               # 3. Loop over all actions
   147        16      19286.0   1205.4      0.0      for l in range(C.L):
   148                                                   # Add the sparse (I - P_l) block to our list
   149        12    2920149.0 243345.8      0.7          A_blocks.append(I_sparse - P[l])
   150                                           
   151                                               # 4. Stack all blocks vertically into one sparse matrix
   152         4    1742591.0 435647.8      0.4      A = vstack(A_blocks, format='csc')
   153                                           
   154                                               # 'highs' is the best for sparse problems
   155         4   79802757.0    2e+07     18.6      res = linprog(c, A_ub=A, b_ub=b, bounds=[None, 0], method='highs')
   156                                           
   157         4      26447.0   6611.8      0.0      J_opt = res.x
   158                                           
   159                                               # Create a list of weighted_J vectors, one for each action l
   160         4       1528.0    382.0      0.0      weighted_J_cols = []
   161        16      30717.0   1919.8      0.0      for l in range(C.L):
   162                                                   # P[l] is (K, K) sparse, J_opt is (K,) dense
   163                                                   # The @ operator performs efficient sparse-dot-dense
   164        12     426911.0  35575.9      0.1          weighted_J_l = P[l] @ J_opt  # Result is a (K,) dense vector
   165        12       8546.0    712.2      0.0          weighted_J_cols.append(weighted_J_l)
   166                                           
   167                                               # Stack the (K,) vectors as columns into a (K, L) dense array
   168         4     148185.0  37046.2      0.0      weighted_J_all = np.stack(weighted_J_cols, axis=1)
   169         4      86249.0  21562.2      0.0      expected_values = Q + weighted_J_all
   170                                           
   171         4      86491.0  21622.8      0.0      optimal_indices = np.argmin(expected_values, axis=1)
   172         4      28065.0   7016.2      0.0      u_opt = np.array(C.input_space)[optimal_indices]
   173                                           
   174         4       1326.0    331.5      0.0      return J_opt, u_opt

  0.00 seconds - /home/gblum/dev/dpc/ComputeExpectedStageCosts.py:27 - compute_expected_stage_cost_solver
  0.05 seconds - /home/gblum/dev/dpc/utils.py:112 - custom_state_space.<locals>._build_d_recursive
  0.10 seconds - /home/gblum/dev/dpc/utils.py:83 - custom_state_space
  0.15 seconds - /home/gblum/dev/dpc/ComputeTransitionProbabilities.py:29 - compute_transition_probabilities_sparse
  0.43 seconds - /home/gblum/dev/dpc/Solver.py:111 - solution_linear_prog_sparse

Timer unit: 1e-09 s

Total time: 0.000245216 s
File: /home/gblum/dev/dpc/ComputeExpectedStageCosts.py
Function: compute_expected_stage_cost_solver at line 27

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    27                                           @profile
    28                                           def compute_expected_stage_cost_solver(C: Const, K: int) -> Tuple[np.array, np.array]:
    29         8      19198.0   2399.8      7.8      costs_row = np.array([
    30         4       2191.0    547.8      0.9          -1,                # Cost for action 0 (None)
    31         4       8418.0   2104.5      3.4          C.lam_weak - 1,    # Cost for action 1 (Weak)
    32         4       2014.0    503.5      0.8          C.lam_strong - 1   # Cost for action 2 (Strong)
    33                                               ])
    34                                           
    35         8      47670.0   5958.8     19.4      b = np.concatenate((
    36         4      74208.0  18552.0     30.3          np.repeat(costs_row[0], K),  # Column 0 of Q
    37         4      28883.0   7220.8     11.8          np.repeat(costs_row[1], K),  # Column 1 of Q
    38         4      31777.0   7944.2     13.0          np.repeat(costs_row[2], K)   # Column 2 of Q
    39                                               ))
    40                                           
    41         4      29412.0   7353.0     12.0      Q = b.reshape((K, C.L), order='F')
    42                                           
    43         4       1445.0    361.2      0.6      return Q, b

Total time: 0.0534734 s
File: /home/gblum/dev/dpc/utils.py
Function: custom_state_space.<locals>._build_d_recursive at line 112

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   112                                               @profile
   113                                               def _build_d_recursive(y, v, current_d_list, current_d_sum, d_index, zero_seen):
   114                                                   """
   115                                                   Recursively builds the D-vector (d1, ..., dM) for a given
   116                                                   (y, v) prefix.
   117                                           
   118                                                   Pruning:
   119                                                   - sum(d) > X-1
   120                                                   - Trailing zeros (if d_i=0, all d_j for j>i must be 0)
   121                                                   - d2=0 if d1=0
   122                                                   """
   123                                                   # --- Base Case: D-vector is complete ---
   124      3006    1368684.0    455.3      2.6          if d_index == M:
   125                                                       # D-vector is built, now start building the H-vector
   126                                                       nonlocal current_index
   127                                           
   128      1908    1093480.0    573.1      2.0              d_tuple = tuple(current_d_list)
   129                                           
   130                                                       # 1. Build the list of allowed H-options for this d_tuple
   131      1908     909585.0    476.7      1.7              h_iterables = [h_options_all] # h1 always has all options
   132                                           
   133      3816    2346637.0    614.9      4.4              for i in range(1, M): # For d2...dM
   134      1908     993975.0    521.0      1.9                  if d_tuple[i] == 0:
   135       846     521940.0    617.0      1.0                      h_iterables.append(h_options_default)
   136                                                           else:
   137      1062     672127.0    632.9      1.3                      h_iterables.append(h_options_all)
   138                                           
   139                                                       # 2. Loop over the product of these allowed H-options
   140      7848    4103899.0    522.9      7.7              for h_tuple in product(*h_iterables):
   141      5940    5050136.0    850.2      9.4                  state = (y, v, *d_tuple, *h_tuple)
   142      5940    3594722.0    605.2      6.7                  state_to_index_dict[state] = current_index
   143      5940    2771555.0    466.6      5.2                  current_index += 1
   144                                           
   145      1908     786717.0    412.3      1.5              return
   146                                           
   147                                                   # --- Recursive Step: Add d_i ---
   148      1098     491264.0    447.4      0.9          if d_index == 0:
   149       126      56412.0    447.7      0.1              d_options = S_d1
   150       972     384618.0    395.7      0.7          elif zero_seen:
   151                                                       d_options = S_d0
   152                                                   else:
   153       972     399603.0    411.1      0.7              d_options = S_d
   154                                           
   155      6570    3047709.0    463.9      5.7          for d in d_options:
   156                                                       # 1. Sum constraint
   157      5472    2791904.0    510.2      5.2              if current_d_sum + d > X_limit:
   158      2466     930802.0    377.5      1.7                  continue
   159                                           
   160                                                       # 3. d1/d2 constraint (d1=0 -> d2>0)
   161                                                       # d_index == 1 is d2
   162      3006    1393102.0    463.4      2.6              if d_index == 1:
   163      2034     923216.0    453.9      1.7                  d1 = current_d_list[0]
   164      2034     752970.0    370.2      1.4                  d2 = d
   165      2034     954114.0    469.1      1.8                  if d1 <= 0 and d2 == 0:
   166       126      47591.0    377.7      0.1                      continue
   167                                           
   168                                                       # Recurse with the added d and pop after completing the branch
   169      2880    1822544.0    632.8      3.4              current_d_list.append(d)
   170      5760    7408193.0   1286.1     13.9              _build_d_recursive(
   171      2880    1104989.0    383.7      2.1                  y, v,
   172      2880     997356.0    346.3      1.9                  current_d_list,
   173      2880    1188337.0    412.6      2.2                  current_d_sum + d,
   174      2880    1230571.0    427.3      2.3                  d_index + 1,
   175                                                           # Update zero_seen flag:
   176                                                           # (zero_seen is True if it was already True, OR
   177                                                           # if we are adding a zero *after* d1)
   178      2880    1431537.0    497.1      2.7                  zero_seen or (d_index > 0 and d == 0)
   179                                                       )
   180      2880    1903061.0    660.8      3.6              current_d_list.pop() # Backtrack

Total time: 0.103714 s
File: /home/gblum/dev/dpc/utils.py
Function: custom_state_space at line 83

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    83                                           @profile
    84                                           def custom_state_space(C: Const) -> Tuple[int, Dict[Tuple[int, ...], int]]:
    85                                               """
    86                                               Computes the state space and returns a state -> index dictionary
    87                                               using a recursive, pruning-based generation method.
    88                                           
    89                                               This function maintains the strict lexicographical ordering
    90                                               from the problem statement, ensuring the state-to-index
    91                                               mapping is identical to the original 'itertools.product' method,
    92                                               but is significantly faster by pruning invalid branches early.
    93                                               """
    94                                           
    95         4       3742.0    935.5      0.0      state_to_index_dict = {}
    96         4       6002.0   1500.5      0.0      current_index = 0
    97                                           
    98                                               # --- Cache constants from C for minor speedup ---
    99         4      44187.0  11046.8      0.0      S_y, S_v = C.S_y, C.S_v
   100         4      31871.0   7967.8      0.0      S_d, S_d1 = C.S_d, C.S_d1
   101         4       6493.0   1623.2      0.0      S_h, S_h_default = C.S_h, C.S_h[0]
   102         4      20053.0   5013.2      0.0      M, X_limit = C.M, C.X - 1
   103                                           
   104                                               # Pre-build the two possible lists for H-options
   105         4       4126.0   1031.5      0.0      h_options_all = S_h
   106         4       2675.0    668.8      0.0      h_options_default = [S_h_default]
   107                                           
   108                                               # Pre build an empty D-options list
   109         4       3152.0    788.0      0.0      S_d0 = [0]
   110                                           
   111                                               # ================== D-Vector Recursive Builder ==================
   112         8    2752346.0 344043.2      2.7      @profile
   113         8       9562.0   1195.2      0.0      def _build_d_recursive(y, v, current_d_list, current_d_sum, d_index, zero_seen):
   114                                                   """
   115                                                   Recursively builds the D-vector (d1, ..., dM) for a given
   116                                                   (y, v) prefix.
   117                                           
   118                                                   Pruning:
   119                                                   - sum(d) > X-1
   120                                                   - Trailing zeros (if d_i=0, all d_j for j>i must be 0)
   121                                                   - d2=0 if d1=0
   122                                                   """
   123                                                   # --- Base Case: D-vector is complete ---
   124                                                   if d_index == M:
   125                                                       # D-vector is built, now start building the H-vector
   126                                                       nonlocal current_index
   127                                           
   128                                                       d_tuple = tuple(current_d_list)
   129                                           
   130                                                       # 1. Build the list of allowed H-options for this d_tuple
   131                                                       h_iterables = [h_options_all] # h1 always has all options
   132                                           
   133                                                       for i in range(1, M): # For d2...dM
   134                                                           if d_tuple[i] == 0:
   135                                                               h_iterables.append(h_options_default)
   136                                                           else:
   137                                                               h_iterables.append(h_options_all)
   138                                           
   139                                                       # 2. Loop over the product of these allowed H-options
   140                                                       for h_tuple in product(*h_iterables):
   141                                                           state = (y, v, *d_tuple, *h_tuple)
   142                                                           state_to_index_dict[state] = current_index
   143                                                           current_index += 1
   144                                           
   145                                                       return
   146                                           
   147                                                   # --- Recursive Step: Add d_i ---
   148                                                   if d_index == 0:
   149                                                       d_options = S_d1
   150                                                   elif zero_seen:
   151                                                       d_options = S_d0
   152                                                   else:
   153                                                       d_options = S_d
   154                                           
   155                                                   for d in d_options:
   156                                                       # 1. Sum constraint
   157                                                       if current_d_sum + d > X_limit:
   158                                                           continue
   159                                           
   160                                                       # 3. d1/d2 constraint (d1=0 -> d2>0)
   161                                                       # d_index == 1 is d2
   162                                                       if d_index == 1:
   163                                                           d1 = current_d_list[0]
   164                                                           d2 = d
   165                                                           if d1 <= 0 and d2 == 0:
   166                                                               continue
   167                                           
   168                                                       # Recurse with the added d and pop after completing the branch
   169                                                       current_d_list.append(d)
   170                                                       _build_d_recursive(
   171                                                           y, v,
   172                                                           current_d_list,
   173                                                           current_d_sum + d,
   174                                                           d_index + 1,
   175                                                           # Update zero_seen flag:
   176                                                           # (zero_seen is True if it was already True, OR
   177                                                           # if we are adding a zero *after* d1)
   178                                                           zero_seen or (d_index > 0 and d == 0)
   179                                                       )
   180                                                       current_d_list.pop() # Backtrack
   181                                           
   182                                               # The outer loops *must* be y, then v, to maintain order
   183        34      20263.0    596.0      0.0      for y in S_y:
   184       156      89534.0    573.9      0.1          for v in S_v:
   185                                                       # Start the recursion for the D-vector
   186       126  100705614.0 799250.9     97.1              _build_d_recursive(y, v, [], 0, 0, False)
   187                                           
   188         4      14350.0   3587.5      0.0      return len(state_to_index_dict), state_to_index_dict

Total time: 0.170742 s
File: /home/gblum/dev/dpc/ComputeTransitionProbabilities.py
Function: compute_transition_probabilities_sparse at line 29

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    29                                           @profile
    30                                           def compute_transition_probabilities_sparse(C:Const, state_to_index_dict, K) -> list:
    31                                               """Computes the transition probability matrix P as a list of sparse matrices."""
    32                                           
    33                                               # Each action in C.input_space will have its own sparse probability matrix
    34         4      31395.0   7848.8      0.0      num_inputs = len(C.input_space)
    35                                           
    36                                               # A calculated probability P[curr_state, next_state, action] is stored as
    37                                               #   coo_data[action] = P[curr_state, next_state, action]
    38                                               #   coo_cols[action] = curr_state
    39                                               #   coo_rows[action] = next_state
    40         4      41319.0  10329.8      0.0      coo_data = [[] for input_i in range(num_inputs)]
    41         4      15875.0   3968.8      0.0      coo_cols = [[] for input_i in range(num_inputs)]
    42         4      15765.0   3941.2      0.0      coo_rows = [[] for input_i in range(num_inputs)]
    43                                           
    44                                               # Helper functions for populating coo table
    45         4      20433.0   5108.2      0.0      append_data = [l.append for l in coo_data]
    46         4      15877.0   3969.2      0.0      append_rows = [l.append for l in coo_rows]
    47         4      13172.0   3293.0      0.0      append_cols = [l.append for l in coo_cols]
    48                                           
    49                                               # Store variables once instead of recalculating
    50         4       9624.0   2406.0      0.0      Y_limit = C.Y - 1
    51         4      15896.0   3974.0      0.0      G_limit = (C.G - 1) / 2
    52         4      32089.0   8022.2      0.0      M = C.M
    53         4       4592.0   1148.0      0.0      X, D_min = C.X, C.D_min
    54         4       7334.0   1833.5      0.0      V_max, g = C.V_max, C.g
    55         4       9244.0   2311.0      0.0      S_h, S_h_0 = C.S_h, C.S_h[0]
    56         4       7507.0   1876.8      0.0      p_height = 1 / len(S_h)
    57         4       5043.0   1260.8      0.0      U_strong_prob = 1 / (2 * C.V_dev + 1)
    58         4      25495.0   6373.8      0.0      W_v = C.W_v
    59                                           
    60         4       3363.0    840.8      0.0      StateVar_Y = 0
    61         4       1799.0    449.8      0.0      StateVar_V = 1
    62         4       1959.0    489.8      0.0      StateVar_D_1 = 2
    63         4       2629.0    657.2      0.0      StateVar_D_2 = StateVar_D_1 + 1
    64         4       2770.0    692.5      0.0      StateVar_D_M = StateVar_D_1 + M - 1
    65         4       1848.0    462.0      0.0      StateVar_H_1 = StateVar_D_M + 1
    66         4       2803.0    700.8      0.0      StateVar_H_2 = StateVar_H_1 + 1
    67         4       1810.0    452.5      0.0      StateVar_H_M = StateVar_H_1 + M - 1
    68                                           
    69         4       2009.0    502.2      0.0      U = [
    70         4       3795.0    948.8      0.0          [0, C.U_no_flap, 1, [0]],
    71         4       2444.0    611.0      0.0          [1, C.U_weak, 1, [0]],
    72         4       2211.0    552.8      0.0          [2, C.U_strong, U_strong_prob, W_v]
    73                                               ]
    74                                           
    75      5944    2381499.0    400.7      1.4      for state_i, state_index in state_to_index_dict.items():
    76      5940    4265947.0    718.2      2.5          y_j = min(Y_limit, max(0, state_i[StateVar_Y] + state_i[StateVar_V]))
    77      5940    2247410.0    378.4      1.3          if state_i[StateVar_D_1] == 0:
    78      1800     975303.0    541.8      0.6              if abs(state_i[StateVar_Y] - state_i[StateVar_H_1]) > G_limit:
    79      1580     417786.0    264.4      0.2                  continue
    80       220     160404.0    729.1      0.1              dhat_j = [state_i[StateVar_D_2] - 1, *state_i[StateVar_D_2:StateVar_D_M], 0]
    81       220     128677.0    584.9      0.1              hhat_j = [*state_i[StateVar_H_2:StateVar_H_M + 1], S_h_0]
    82                                                   else:
    83      4140    2631139.0    635.5      1.5              dhat_j = [state_i[StateVar_D_1] - 1, *state_i[StateVar_D_2:StateVar_D_M + 1]]
    84      4140    2000807.0    483.3      1.2              hhat_j = [*state_i[StateVar_H_1:StateVar_H_M + 1]]
    85      4360    2415322.0    554.0      1.4          s = X - 1 - sum(dhat_j)
    86      4360    1938562.0    444.6      1.1          p_spawn = (s - (D_min - 1)) / (X - D_min)
    87      4360    3038098.0    696.8      1.8          p_spawn = min(1, max(0, p_spawn))
    88      4360    1589977.0    364.7      0.9          p_no_spawn = 1 - p_spawn
    89      4360    1562614.0    358.4      0.9          m_min = M - 1
    90      6808    3219067.0    472.8      1.9          for m in range(1, M):
    91      4360    1627612.0    373.3      1.0              if dhat_j[m] == 0:
    92      1912     590619.0    308.9      0.3                  m_min = m
    93      1912     582210.0    304.5      0.3                  break
    94      4360    1384594.0    317.6      0.8          dspawn_j = None
    95      4360    1415053.0    324.6      0.8          if p_spawn > 0:
    96       940    2012984.0   2141.5      1.2              dspawn_j = copy(dhat_j)
    97       940     350872.0    373.3      0.2              dspawn_j[m_min] = s
    98       940    1536098.0   1634.1      0.9              hspawn_j = copy(hhat_j)
    99                                           
   100                                                   # Each input will push to a seperate index in coo_*
   101                                                   # Important note: Duplicate entries will be SUMMED!
   102                                                   # This means that we do not have to worry about two inputs resulting in the same next_state (See += in compute_transition_probabilities)
   103     17440    6898714.0    395.6      4.0          for input_index, u_k, p_flap, W_v_list in U:
   104     34880   11055211.0    316.9      6.5              for w_v in W_v_list:
   105     21800   16213922.0    743.8      9.5                  v_j = min(V_max, max(-V_max, state_i[StateVar_V] + u_k + w_v - g))
   106                                           
   107                                                           # Case 1: No spawn
   108     21800    6797414.0    311.8      4.0                  if p_no_spawn > 0:
   109     20540    9638161.0    469.2      5.6                      next_state = (y_j, v_j, *dhat_j, *hhat_j)
   110     20540    8251235.0    401.7      4.8                      j_index = state_to_index_dict[next_state]
   111                                           
   112     20540    8710092.0    424.1      5.1                      append_data[input_index](p_flap * p_no_spawn)
   113     20540    7319019.0    356.3      4.3                      append_rows[input_index](state_index)
   114     20540    7358864.0    358.3      4.3                      append_cols[input_index](j_index)
   115                                           
   116                                                           # Case 2: Spawn
   117     21800    7143174.0    327.7      4.2                  if p_spawn > 0:
   118      4700    1818627.0    386.9      1.1                      p_combined = p_flap * p_spawn * p_height
   119     14100    4283896.0    303.8      2.5                      for height in S_h:
   120      9400    2727460.0    290.2      1.6                          hspawn_j[m_min] = height
   121      9400    4064048.0    432.3      2.4                          next_state = (y_j, v_j, *dspawn_j, *hspawn_j)
   122      9400    3861029.0    410.7      2.3                          j_index = state_to_index_dict[next_state]
   123                                           
   124      9400    3354807.0    356.9      2.0                          append_data[input_index](p_combined)
   125      9400    3318136.0    353.0      1.9                          append_rows[input_index](state_index)
   126      9400    3591935.0    382.1      2.1                          append_cols[input_index](j_index)
   127                                           
   128                                               # Construct the sparse matrices
   129         4       3761.0    940.2      0.0      P_sparse_list = []
   130        16      92561.0   5785.1      0.1      for l in range(C.L):
   131        24   15432819.0 643034.1      9.0          P_l = sparse_matrix(
   132        12      13105.0   1092.1      0.0              (coo_data[l], (coo_rows[l], coo_cols[l])),
   133        12       4866.0    405.5      0.0              shape=(K, K)
   134                                                   )
   135        12      14948.0   1245.7      0.0          P_sparse_list.append(P_l)
   136                                           
   137         4       1213.0    303.2      0.0      return P_sparse_list

Total time: 0.468975 s
File: /home/gblum/dev/dpc/Solver.py
Function: solution_linear_prog_sparse at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                           def solution_linear_prog_sparse(C: Const) -> tuple[np.array, np.array]:
   112                                               """Computes the optimal cost and the optimal control policy.
   113                                           
   114                                               You can solve the SSP by any method:
   115                                               - Value Iteration
   116                                               - Policy Iteration
   117                                               - Linear Programming
   118                                               - A combination of the above
   119                                               - Others?
   120                                           
   121                                               Args:
   122                                                   C (Const): The constants describing the problem instance.
   123                                           
   124                                               Returns:
   125                                                   np.array: The optimal cost to go for the stochastic SPP,
   126                                                       of shape (C.K,), where C.K is the number of states.
   127                                                   np.array: The optimal control policy for the stochastic SPP,
   128                                                       of shape (C.K,), where each entry is in {0,...,C.L-1}.
   129                                               """
   130         4  104002790.0  2.6e+07     22.2      K, state_dict = custom_state_space(C)
   131                                           
   132         4     107155.0  26788.8      0.0      J_opt = np.zeros(K)
   133         4      24688.0   6172.0      0.0      u_opt = np.zeros(K)
   134                                           
   135         4  276605125.0 6.92e+07     59.0      P = compute_transition_probabilities(C, state_dict, K)
   136         4     306720.0  76680.0      0.1      Q, b = compute_expected_stage_cost(C, K)
   137                                           
   138         4      51144.0  12786.0      0.0      c = np.full(K, -1, np.int64)
   139                                           
   140                                               # 1. Create a sparse identity matrix
   141         4     579675.0 144918.8      0.1      I_sparse = eye(K, format='csc')
   142                                           
   143                                               # 2. Create a list to hold the sparse blocks (I - P_l)
   144         4       2321.0    580.2      0.0      A_blocks = []
   145                                           
   146                                               # 3. Loop over all actions
   147        16      32282.0   2017.6      0.0      for l in range(C.L):
   148                                                   # Add the sparse (I - P_l) block to our list
   149        12    3098532.0 258211.0      0.7          A_blocks.append(I_sparse - P[l])
   150                                           
   151                                               # 4. Stack all blocks vertically into one sparse matrix
   152         4    1758341.0 439585.2      0.4      A = vstack(A_blocks, format='csc')
   153                                           
   154                                               # 'highs' is the best for sparse problems
   155         4   81546026.0 2.04e+07     17.4      res = linprog(c, A_ub=A, b_ub=b, bounds=[None, 0], method='highs')
   156                                           
   157         4      24036.0   6009.0      0.0      J_opt = res.x
   158                                           
   159                                               # Create a list of weighted_J vectors, one for each action l
   160         4       1740.0    435.0      0.0      weighted_J_cols = []
   161        16      29568.0   1848.0      0.0      for l in range(C.L):
   162                                                   # P[l] is (K, K) sparse, J_opt is (K,) dense
   163                                                   # The @ operator performs efficient sparse-dot-dense
   164        12     409067.0  34088.9      0.1          weighted_J_l = P[l] @ J_opt  # Result is a (K,) dense vector
   165        12       9276.0    773.0      0.0          weighted_J_cols.append(weighted_J_l)
   166                                           
   167                                               # Stack the (K,) vectors as columns into a (K, L) dense array
   168         4     184549.0  46137.2      0.0      weighted_J_all = np.stack(weighted_J_cols, axis=1)
   169         4      80857.0  20214.2      0.0      expected_values = Q + weighted_J_all
   170                                           
   171         4      90295.0  22573.8      0.0      optimal_indices = np.argmin(expected_values, axis=1)
   172         4      29385.0   7346.2      0.0      u_opt = np.array(C.input_space)[optimal_indices]
   173                                           
   174         4       1619.0    404.8      0.0      return J_opt, u_opt

  0.00 seconds - /home/gblum/dev/dpc/ComputeExpectedStageCosts.py:27 - compute_expected_stage_cost_solver
  0.05 seconds - /home/gblum/dev/dpc/utils.py:112 - custom_state_space.<locals>._build_d_recursive
  0.10 seconds - /home/gblum/dev/dpc/utils.py:83 - custom_state_space
  0.17 seconds - /home/gblum/dev/dpc/ComputeTransitionProbabilities.py:29 - compute_transition_probabilities_sparse
  0.47 seconds - /home/gblum/dev/dpc/Solver.py:111 - solution_linear_prog_sparse

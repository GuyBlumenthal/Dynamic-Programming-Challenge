Timer unit: 1e-09 s

Total time: 0.000212173 s
File: /home/gblum/dev/dpc/ComputeExpectedStageCosts.py
Function: compute_expected_stage_cost_solver at line 27

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    27                                           @profile
    28                                           def compute_expected_stage_cost_solver(C: Const, K: int) -> Tuple[np.array, np.array]:
    29         8      16385.0   2048.1      7.7      costs_row = np.array([
    30         4       1596.0    399.0      0.8          -1,                # Cost for action 0 (None)
    31         4       4628.0   1157.0      2.2          C.lam_weak - 1,    # Cost for action 1 (Weak)
    32         4       1956.0    489.0      0.9          C.lam_strong - 1   # Cost for action 2 (Strong)
    33                                               ])
    34                                           
    35         8      39274.0   4909.2     18.5      b = np.concatenate((
    36         4      67773.0  16943.2     31.9          np.repeat(costs_row[0], K),  # Column 0 of Q
    37         4      29805.0   7451.2     14.0          np.repeat(costs_row[1], K),  # Column 1 of Q
    38         4      23828.0   5957.0     11.2          np.repeat(costs_row[2], K)   # Column 2 of Q
    39                                               ))
    40                                           
    41         4      25484.0   6371.0     12.0      Q = b.reshape((K, C.L), order='F')
    42                                           
    43         4       1444.0    361.0      0.7      return Q, b

Total time: 0.0323387 s
File: /home/gblum/dev/dpc/utils.py
Function: custom_state_space.<locals>._build_d_recursive at line 121

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   121                                               @profile
   122                                               def _build_d_recursive(y, v, current_d_list, current_d_sum, d_index, spot0):
   123                                                   """
   124                                                   Recursively builds the D-vector (d1, ..., dM) for a given
   125                                                   (y, v) prefix.
   126                                           
   127                                                   Pruning:
   128                                                   - sum(d) > X-1
   129                                                   - Trailing zeros (if d_i=0, all d_j for j>i must be 0)
   130                                                   - d2=0 if d1=0
   131                                                   """
   132                                                   # --- Base Case: D-vector is complete ---
   133      3006     927739.0    308.6      2.9          if d_index == M:
   134                                                       # D-vector is built, now start building the H-vector
   135                                                       nonlocal current_index
   136                                           
   137      1908     585004.0    306.6      1.8              h_iterable = possible_h_iterables[spot0]
   138                                           
   139      1908    1032494.0    541.1      3.2              prefix = (y, v) + tuple(current_d_list)
   140                                           
   141                                                       # 2. Loop over the product of these allowed H-options
   142      7848    2209789.0    281.6      6.8              for h_tuple in h_iterable:
   143      5940    2717142.0    457.4      8.4                  state = prefix + h_tuple
   144      5940    2607031.0    438.9      8.1                  state_to_index_dict[state] = current_index
   145      5940    1862773.0    313.6      5.8                  current_index += 1
   146                                           
   147      1908     534571.0    280.2      1.7              return
   148                                           
   149                                                   # --- Recursive Step: Add d_i ---
   150      1098     344165.0    313.4      1.1          if d_index == 0:
   151       126      37334.0    296.3      0.1              d_options = S_d1
   152       972     289114.0    297.4      0.9          elif spot0 > 0:
   153                                                       d_options = S_d0
   154                                                   else:
   155       972     274735.0    282.6      0.8              d_options = S_d
   156                                           
   157      6570    1889788.0    287.6      5.8          for d in d_options:
   158                                                       # 1. Sum constraint
   159      5472    1804306.0    329.7      5.6              if current_d_sum + d > X_limit:
   160      2466     582240.0    236.1      1.8                  continue
   161                                           
   162                                                       # 3. d1/d2 constraint (d1=0 -> d2>0)
   163                                                       # d_index == 1 is d2
   164      3006     921498.0    306.6      2.8              if d_index == 1:
   165      2034     613465.0    301.6      1.9                  d1 = current_d_list[0]
   166      2034     529683.0    260.4      1.6                  d2 = d
   167      2034     616508.0    303.1      1.9                  if d1 <= 0 and d2 == 0:
   168       126      29926.0    237.5      0.1                      continue
   169                                           
   170      2880     807077.0    280.2      2.5              next_spot0 = spot0
   171      2880    1098375.0    381.4      3.4              if spot0 == 0 and d_index > 0 and d == 0:
   172       846     225758.0    266.9      0.7                  next_spot0 = d_index  # This is the first zero
   173                                           
   174                                                       # Recurse with the added d
   175      2880     985306.0    342.1      3.0              current_d_list[d_index] = d
   176      5760    5094481.0    884.5     15.8              _build_d_recursive(
   177      2880     744864.0    258.6      2.3                  y, v,
   178      2880     711118.0    246.9      2.2                  current_d_list,
   179      2880     793260.0    275.4      2.5                  current_d_sum + d,
   180      2880     794548.0    275.9      2.5                  d_index + 1,
   181                                                           # Update zero_seen flag:
   182                                                           # (zero_seen is True if it was already True, OR
   183                                                           # if we are adding a zero *after* d1)
   184      2880     674621.0    234.2      2.1                  next_spot0
   185                                                       )

Total time: 0.0644573 s
File: /home/gblum/dev/dpc/utils.py
Function: custom_state_space at line 83

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    83                                           @profile
    84                                           def custom_state_space(C: Const) -> Tuple[int, Dict[Tuple[int, ...], int]]:
    85                                               """
    86                                               Computes the state space and returns a state -> index dictionary
    87                                               using a recursive, pruning-based generation method.
    88                                           
    89                                               This function maintains the strict lexicographical ordering
    90                                               from the problem statement, ensuring the state-to-index
    91                                               mapping is identical to the original 'itertools.product' method,
    92                                               but is significantly faster by pruning invalid branches early.
    93                                               """
    94                                           
    95         4       2598.0    649.5      0.0      state_to_index_dict = {}
    96         4       3413.0    853.2      0.0      current_index = 0
    97                                           
    98                                               # --- Cache constants from C for minor speedup ---
    99         4      27682.0   6920.5      0.0      S_y, S_v = C.S_y, C.S_v
   100         4      20387.0   5096.8      0.0      S_d, S_d1 = C.S_d, C.S_d1
   101         4      11812.0   2953.0      0.0      S_h, S_h_default = C.S_h, C.S_h[0]
   102         4      23847.0   5961.8      0.0      M, X_limit = C.M, C.X - 1
   103                                           
   104                                               # Pre-build the two possible lists for H-options
   105         4       2315.0    578.8      0.0      h_options_all = S_h
   106         4       3023.0    755.8      0.0      h_options_default = [S_h_default]
   107                                           
   108                                               # Pre build an empty D-options list
   109         4       1503.0    375.8      0.0      S_d0 = [0]
   110                                           
   111                                           
   112         4      14009.0   3502.2      0.0      possible_h_iterables = [[h_options_all] + [h_options_all for i in range(1, M)]]
   113         8       4916.0    614.5      0.0      for spot0 in range(1, M):
   114         8      16499.0   2062.4      0.0          possible_h_iterables.append([h_options_all] + [
   115                                                       h_options_default if i >= spot0 else h_options_all
   116         4       1491.0    372.8      0.0              for i in range(1, M)
   117                                                   ])
   118         4      20531.0   5132.8      0.0      possible_h_iterables = [list(product(*h_iter)) for h_iter in possible_h_iterables]
   119                                           
   120                                               # ================== D-Vector Recursive Builder ==================
   121         8    1249116.0 156139.5      1.9      @profile
   122         8       5025.0    628.1      0.0      def _build_d_recursive(y, v, current_d_list, current_d_sum, d_index, spot0):
   123                                                   """
   124                                                   Recursively builds the D-vector (d1, ..., dM) for a given
   125                                                   (y, v) prefix.
   126                                           
   127                                                   Pruning:
   128                                                   - sum(d) > X-1
   129                                                   - Trailing zeros (if d_i=0, all d_j for j>i must be 0)
   130                                                   - d2=0 if d1=0
   131                                                   """
   132                                                   # --- Base Case: D-vector is complete ---
   133                                                   if d_index == M:
   134                                                       # D-vector is built, now start building the H-vector
   135                                                       nonlocal current_index
   136                                           
   137                                                       h_iterable = possible_h_iterables[spot0]
   138                                           
   139                                                       prefix = (y, v) + tuple(current_d_list)
   140                                           
   141                                                       # 2. Loop over the product of these allowed H-options
   142                                                       for h_tuple in h_iterable:
   143                                                           state = prefix + h_tuple
   144                                                           state_to_index_dict[state] = current_index
   145                                                           current_index += 1
   146                                           
   147                                                       return
   148                                           
   149                                                   # --- Recursive Step: Add d_i ---
   150                                                   if d_index == 0:
   151                                                       d_options = S_d1
   152                                                   elif spot0 > 0:
   153                                                       d_options = S_d0
   154                                                   else:
   155                                                       d_options = S_d
   156                                           
   157                                                   for d in d_options:
   158                                                       # 1. Sum constraint
   159                                                       if current_d_sum + d > X_limit:
   160                                                           continue
   161                                           
   162                                                       # 3. d1/d2 constraint (d1=0 -> d2>0)
   163                                                       # d_index == 1 is d2
   164                                                       if d_index == 1:
   165                                                           d1 = current_d_list[0]
   166                                                           d2 = d
   167                                                           if d1 <= 0 and d2 == 0:
   168                                                               continue
   169                                           
   170                                                       next_spot0 = spot0
   171                                                       if spot0 == 0 and d_index > 0 and d == 0:
   172                                                           next_spot0 = d_index  # This is the first zero
   173                                           
   174                                                       # Recurse with the added d
   175                                                       current_d_list[d_index] = d
   176                                                       _build_d_recursive(
   177                                                           y, v,
   178                                                           current_d_list,
   179                                                           current_d_sum + d,
   180                                                           d_index + 1,
   181                                                           # Update zero_seen flag:
   182                                                           # (zero_seen is True if it was already True, OR
   183                                                           # if we are adding a zero *after* d1)
   184                                                           next_spot0
   185                                                       )
   186                                           
   187                                               # The outer loops *must* be y, then v, to maintain order
   188        34      14344.0    421.9      0.0      for y in S_y:
   189       156      51668.0    331.2      0.1          for v in S_v:
   190       126      92753.0    736.1      0.1              current_d_list_for_v = [0] * M
   191                                                       # Start the recursion for the D-vector
   192       126   62880399.0 499050.8     97.6              _build_d_recursive(y, v, current_d_list_for_v, 0, 0, 0)
   193                                           
   194         4       9984.0   2496.0      0.0      return len(state_to_index_dict), state_to_index_dict

Total time: 0.153037 s
File: /home/gblum/dev/dpc/ComputeTransitionProbabilities.py
Function: compute_transition_probabilities_sparse at line 28

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    28                                           @profile
    29                                           def compute_transition_probabilities_sparse(C:Const, state_to_index_dict, K) -> list:
    30                                               """Computes the transition probability matrix P as a list of sparse matrices."""
    31                                           
    32                                               # Each action in C.input_space will have its own sparse probability matrix
    33         4      27339.0   6834.8      0.0      num_inputs = len(C.input_space)
    34                                           
    35                                               # A calculated probability P[curr_state, next_state, action] is stored as
    36                                               #   coo_data[action] = P[curr_state, next_state, action]
    37                                               #   coo_cols[action] = curr_state
    38                                               #   coo_rows[action] = next_state
    39         4      30109.0   7527.2      0.0      coo_data = [[] for input_i in range(num_inputs)]
    40         4      11218.0   2804.5      0.0      coo_cols = [[] for input_i in range(num_inputs)]
    41         4       9627.0   2406.8      0.0      coo_rows = [[] for input_i in range(num_inputs)]
    42                                           
    43                                               # Helper functions for populating coo table
    44         4      16757.0   4189.2      0.0      append_data = [l.append for l in coo_data]
    45         4      11521.0   2880.2      0.0      append_rows = [l.append for l in coo_rows]
    46         4       8649.0   2162.2      0.0      append_cols = [l.append for l in coo_cols]
    47                                           
    48                                               # Store variables once instead of recalculating
    49         4       3605.0    901.2      0.0      Y_limit = C.Y - 1
    50         4       6850.0   1712.5      0.0      G_limit = (C.G - 1) / 2
    51         4      21282.0   5320.5      0.0      M = C.M
    52         4       3004.0    751.0      0.0      X, D_min = C.X, C.D_min
    53         4       4238.0   1059.5      0.0      V_max, g = C.V_max, C.g
    54         4       2718.0    679.5      0.0      S_h, S_h_0 = C.S_h, C.S_h[0]
    55         4       2050.0    512.5      0.0      p_height = 1 / len(S_h)
    56         4       4448.0   1112.0      0.0      U_strong_prob = 1 / (2 * C.V_dev + 1)
    57         4      35506.0   8876.5      0.0      W_v = C.W_v
    58                                           
    59         4       2255.0    563.8      0.0      StateVar_Y = 0
    60         4       2740.0    685.0      0.0      StateVar_V = 1
    61         4       2526.0    631.5      0.0      StateVar_D_1 = 2
    62         4       2285.0    571.2      0.0      StateVar_D_2 = StateVar_D_1 + 1
    63         4       3106.0    776.5      0.0      StateVar_D_M = StateVar_D_1 + M - 1
    64         4       1857.0    464.2      0.0      StateVar_H_1 = StateVar_D_M + 1
    65         4       1583.0    395.8      0.0      StateVar_H_2 = StateVar_H_1 + 1
    66         4       1293.0    323.2      0.0      StateVar_H_M = StateVar_H_1 + M - 1
    67                                           
    68         4       1957.0    489.2      0.0      U = [
    69         4       3334.0    833.5      0.0          [0, C.U_no_flap, 1, [0]],
    70         4       3054.0    763.5      0.0          [1, C.U_weak, 1, [0]],
    71         4       2512.0    628.0      0.0          [2, C.U_strong, U_strong_prob, W_v]
    72                                               ]
    73                                           
    74                                               # Cache all possible Vs
    75         4      10172.0   2543.0      0.0      v_space = C.S_v
    76         4       5661.0   1415.2      0.0      u_space = C.input_space
    77                                           
    78         4      17289.0   4322.2      0.0      max_v = V_max + max(C.input_space) + max(W_v) - g
    79         4       9434.0   2358.5      0.0      min_v = -V_max + min(C.input_space) + min(W_v) - g
    80                                           
    81         4       4475.0   1118.8      0.0      Y_LOOKUP_OFFSET = abs(0-V_max)
    82         4      52720.0  13180.0      0.0      Y_LOOKUP = [min(Y_limit, max(0, y_v)) for y_v in range(0-V_max, Y_limit+V_max+1)]
    83                                           
    84         4       2664.0    666.0      0.0      V_LOOKUP_OFFSET = abs(min_v)
    85         4      53380.0  13345.0      0.0      V_LOOKUP = [min(V_max, max(-V_max, v)) for v in range(min_v, max_v+1)]
    86                                           
    87      5944    2309492.0    388.5      1.5      for state_i, state_index in state_to_index_dict.items():
    88                                                   # y_j = min(Y_limit, max(0, state_i[StateVar_Y] + state_i[StateVar_V]))
    89      5940    2461514.0    414.4      1.6          y_j = Y_LOOKUP[Y_LOOKUP_OFFSET + state_i[StateVar_Y] + state_i[StateVar_V]]
    90      5940    2030824.0    341.9      1.3          if state_i[StateVar_D_1] == 0:
    91      1800     908777.0    504.9      0.6              if abs(state_i[StateVar_Y] - state_i[StateVar_H_1]) > G_limit:
    92      1580     390649.0    247.2      0.3                  continue
    93       220     144451.0    656.6      0.1              dhat_j = [state_i[StateVar_D_2] - 1, *state_i[StateVar_D_2+1:StateVar_D_M+1], 0]
    94       220     111320.0    506.0      0.1              hhat_j = [*state_i[StateVar_H_2:StateVar_H_M + 1], S_h_0]
    95                                                   else:
    96      4140    2388552.0    576.9      1.6              dhat_j = [state_i[StateVar_D_1] - 1, *state_i[StateVar_D_2:StateVar_D_M + 1]]
    97      4140    1837906.0    443.9      1.2              hhat_j = [*state_i[StateVar_H_1:StateVar_H_M + 1]]
    98      4360    2322523.0    532.7      1.5          s = X - 1 - sum(dhat_j)
    99      4360    1796663.0    412.1      1.2          p_spawn = (s - (D_min - 1)) / (X - D_min)
   100                                                   # TODO: Can p_spawn ever be 1 or greater?
   101      4360    1493988.0    342.7      1.0          if p_spawn < 0:
   102      2768     801836.0    289.7      0.5              p_spawn = 0
   103      1592     553185.0    347.5      0.4          elif p_spawn > 1:
   104                                                       p_spawn = 1
   105                                                   # p_spawn = min(1, max(0, p_spawn))
   106      4360    1549655.0    355.4      1.0          p_no_spawn = 1 - p_spawn
   107      4360    1427068.0    327.3      0.9          m_min = M - 1
   108      6808    3127587.0    459.4      2.0          for m in range(1, M):
   109      4360    1597372.0    366.4      1.0              if dhat_j[m] == 0:
   110      1912     538660.0    281.7      0.4                  m_min = m
   111      1912     539022.0    281.9      0.4                  break
   112      4360    1309782.0    300.4      0.9          dspawn_j = None
   113      4360    1424015.0    326.6      0.9          if p_spawn > 0:
   114       940     358912.0    381.8      0.2              dspawn_j = dhat_j[:]
   115       940     321403.0    341.9      0.2              dspawn_j[m_min] = s
   116       940     419146.0    445.9      0.3              dspawn_j = tuple(dspawn_j)
   117       940     418005.0    444.7      0.3              hspawn_j = hhat_j[:]
   118       940     466464.0    496.2      0.3              h_prefix = tuple(hhat_j[:m_min])
   119       940     459559.0    488.9      0.3              h_suffix = tuple(hhat_j[m_min+1:])
   120                                           
   121      4360    1780452.0    408.4      1.2          dhat_tuple = tuple(dhat_j)
   122      4360    1484254.0    340.4      1.0          hhat_tuple = tuple(hhat_j)
   123                                           
   124                                                   # Each input will push to a seperate index in coo_*
   125                                                   # Important note: Duplicate entries will be SUMMED!
   126                                                   # This means that we do not have to worry about two inputs resulting in the same next_state (See += in compute_transition_probabilities)
   127     17440    6274214.0    359.8      4.1          for input_index, u_k, p_flap, W_v_list in U:
   128     34880   10346004.0    296.6      6.8              for w_v in W_v_list:
   129     21800    9308128.0    427.0      6.1                  v_j = V_LOOKUP[V_LOOKUP_OFFSET + state_i[StateVar_V] + u_k + w_v - g]
   130                                           
   131                                                           # Case 1: No spawn
   132     21800    6284539.0    288.3      4.1                  if p_no_spawn > 0:
   133     20540    8716206.0    424.4      5.7                      next_state = (y_j, v_j) + dhat_tuple + hhat_tuple
   134     20540    7805608.0    380.0      5.1                      j_index = state_to_index_dict[next_state]
   135                                           
   136     20540    8284467.0    403.3      5.4                      append_data[input_index](p_flap * p_no_spawn)
   137     20540    6960776.0    338.9      4.5                      append_rows[input_index](state_index)
   138     20540    7147638.0    348.0      4.7                      append_cols[input_index](j_index)
   139                                           
   140                                                           # Case 2: Spawn
   141     21800    6972541.0    319.8      4.6                  if p_spawn > 0:
   142      4700    1727874.0    367.6      1.1                      spawn_prefix = (y_j, v_j) + dspawn_j
   143      4700    1655747.0    352.3      1.1                      p_combined = p_flap * p_spawn * p_height
   144     14100    3968222.0    281.4      2.6                      for height in S_h:
   145      9400    3861409.0    410.8      2.5                          next_state = spawn_prefix + h_prefix + (height,) + h_suffix
   146      9400    3583643.0    381.2      2.3                          j_index = state_to_index_dict[next_state]
   147                                           
   148      9400    3245456.0    345.3      2.1                          append_data[input_index](p_combined)
   149      9400    3120764.0    332.0      2.0                          append_rows[input_index](state_index)
   150      9400    3262490.0    347.1      2.1                          append_cols[input_index](j_index)
   151                                           
   152                                               # Construct the sparse matrices
   153         4       1434.0    358.5      0.0      P_sparse_list = []
   154        16      47421.0   2963.8      0.0      for l in range(C.L):
   155                                                   # Build as COO first (fastest for this input)
   156        24   10801220.0 450050.8      7.1          P_l_coo = coo_matrix(
   157        12       8957.0    746.4      0.0              (coo_data[l], (coo_rows[l], coo_cols[l])),
   158        12       3466.0    288.8      0.0              shape=(K, K)
   159                                                   )
   160                                                   # Convert to CSC (fast, sums duplicates)
   161        12    2479140.0 206595.0      1.6          P_l = P_l_coo.tocsc()
   162        12      12353.0   1029.4      0.0          P_sparse_list.append(P_l)
   163                                           
   164         4       1141.0    285.2      0.0      return P_sparse_list

Total time: 0.423527 s
File: /home/gblum/dev/dpc/Solver.py
Function: solution_linear_prog_sparse at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                           def solution_linear_prog_sparse(C: Const) -> tuple[np.array, np.array]:
   112                                               """Computes the optimal cost and the optimal control policy.
   113                                           
   114                                               You can solve the SSP by any method:
   115                                               - Value Iteration
   116                                               - Policy Iteration
   117                                               - Linear Programming
   118                                               - A combination of the above
   119                                               - Others?
   120                                           
   121                                               Args:
   122                                                   C (Const): The constants describing the problem instance.
   123                                           
   124                                               Returns:
   125                                                   np.array: The optimal cost to go for the stochastic SPP,
   126                                                       of shape (C.K,), where C.K is the number of states.
   127                                                   np.array: The optimal control policy for the stochastic SPP,
   128                                                       of shape (C.K,), where each entry is in {0,...,C.L-1}.
   129                                               """
   130         4   64707205.0 1.62e+07     15.3      K, state_dict = custom_state_space(C)
   131                                           
   132         4      52029.0  13007.2      0.0      J_opt = np.zeros(K)
   133         4       9148.0   2287.0      0.0      u_opt = np.zeros(K)
   134                                           
   135         4  261157598.0 6.53e+07     61.7      P = compute_transition_probabilities(C, state_dict, K)
   136         4     275457.0  68864.2      0.1      Q, b = compute_expected_stage_cost(C, K)
   137                                           
   138         4      44181.0  11045.2      0.0      c = np.full(K, -1, np.int64)
   139                                           
   140                                               # 1. Create a sparse identity matrix
   141         4     629645.0 157411.2      0.1      I_sparse = eye(K, format='csc')
   142                                           
   143                                               # 2. Create a list to hold the sparse blocks (I - P_l)
   144         4       1986.0    496.5      0.0      A_blocks = []
   145                                           
   146                                               # 3. Loop over all actions
   147        16      20751.0   1296.9      0.0      for l in range(C.L):
   148                                                   # Add the sparse (I - P_l) block to our list
   149        12    3370444.0 280870.3      0.8          A_blocks.append(I_sparse - P[l])
   150                                           
   151                                               # 4. Stack all blocks vertically into one sparse matrix
   152         4    2157186.0 539296.5      0.5      A = vstack(A_blocks, format='csc')
   153                                           
   154                                               # 'highs' is the best for sparse problems
   155         4   90239083.0 2.26e+07     21.3      res = linprog(c, A_ub=A, b_ub=b, bounds=[None, 0], method='highs')
   156                                           
   157         4      25582.0   6395.5      0.0      J_opt = res.x
   158                                           
   159                                               # Create a list of weighted_J vectors, one for each action l
   160         4       1835.0    458.8      0.0      weighted_J_cols = []
   161        16      30602.0   1912.6      0.0      for l in range(C.L):
   162                                                   # P[l] is (K, K) sparse, J_opt is (K,) dense
   163                                                   # The @ operator performs efficient sparse-dot-dense
   164        12     416300.0  34691.7      0.1          weighted_J_l = P[l] @ J_opt  # Result is a (K,) dense vector
   165        12       8432.0    702.7      0.0          weighted_J_cols.append(weighted_J_l)
   166                                           
   167                                               # Stack the (K,) vectors as columns into a (K, L) dense array
   168         4     161055.0  40263.8      0.0      weighted_J_all = np.stack(weighted_J_cols, axis=1)
   169         4      89175.0  22293.8      0.0      expected_values = Q + weighted_J_all
   170                                           
   171         4      96187.0  24046.8      0.0      optimal_indices = np.argmin(expected_values, axis=1)
   172         4      31744.0   7936.0      0.0      u_opt = np.array(C.input_space)[optimal_indices]
   173                                           
   174         4       1597.0    399.2      0.0      return J_opt, u_opt

  0.00 seconds - /home/gblum/dev/dpc/ComputeExpectedStageCosts.py:27 - compute_expected_stage_cost_solver
  0.03 seconds - /home/gblum/dev/dpc/utils.py:121 - custom_state_space.<locals>._build_d_recursive
  0.06 seconds - /home/gblum/dev/dpc/utils.py:83 - custom_state_space
  0.15 seconds - /home/gblum/dev/dpc/ComputeTransitionProbabilities.py:28 - compute_transition_probabilities_sparse
  0.42 seconds - /home/gblum/dev/dpc/Solver.py:111 - solution_linear_prog_sparse

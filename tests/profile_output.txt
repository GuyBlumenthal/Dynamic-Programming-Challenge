Timer unit: 1e-09 s

Total time: 0.00228576 s
Average time: 2.8572e-05 s
File: /home/gblum/dev/dpc/ComputeExpectedStageCosts.py
Function: compute_expected_stage_cost_solver at line 23

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    23                                           def compute_expected_stage_cost_solver(C: Const, K: int) -> Tuple[np.array, np.array]:
    24        80     184797.0   2310.0      8.1      costs_row = np.array([
    25        40      19827.0    495.7      0.9          -1,                # Cost for action 0 (None)
    26        40      47612.0   1190.3      2.1          C.lam_weak - 1,    # Cost for action 1 (Weak)
    27        40      18828.0    470.7      0.8          C.lam_strong - 1   # Cost for action 2 (Strong)
    28                                               ])
    29                                           
    30        80     422392.0   5279.9     18.5      b = np.concatenate((
    31        40     735945.0  18398.6     32.2          np.repeat(costs_row[0], K),  # Column 0 of Q
    32        40     290637.0   7265.9     12.7          np.repeat(costs_row[1], K),  # Column 1 of Q
    33        40     256367.0   6409.2     11.2          np.repeat(costs_row[2], K)   # Column 2 of Q
    34                                               ))
    35                                           
    36        40     294274.0   7356.9     12.9      Q = b.reshape((K, C.L), order='F')
    37                                           
    38        40      15079.0    377.0      0.7      return Q, b

Total time: 2.87561 s
Average time: 0.0359451 s
File: /home/gblum/dev/dpc/ComputeTransitionProbabilities.py
Function: compute_transition_probabilities_sparse at line 28

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    28                                           def compute_transition_probabilities_sparse(C:Const, state_to_index_array, K, valid_states_with_indices) -> list:
    29                                               """Computes the transition probability matrix P as a list of sparse matrices."""
    30                                           
    31                                               # Each action in C.input_space will have its own sparse probability matrix
    32        80     764972.0   9562.1      0.0      num_inputs = len(C.input_space)
    33                                           
    34                                               # A calculated probability P[curr_state, next_state, action] is stored as
    35                                               #   coo_data[action] = P[curr_state, next_state, action]
    36                                               #   coo_cols[action] = curr_state
    37                                               #   coo_rows[action] = next_state
    38        80     639745.0   7996.8      0.0      coo_data = [[] for input_i in range(num_inputs)]
    39        80     260123.0   3251.5      0.0      coo_cols = [[] for input_i in range(num_inputs)]
    40        80     249857.0   3123.2      0.0      coo_rows = [[] for input_i in range(num_inputs)]
    41                                           
    42                                               # Helper functions for populating coo table
    43        80     294568.0   3682.1      0.0      append_data = [l.append for l in coo_data]
    44        80     203447.0   2543.1      0.0      append_rows = [l.append for l in coo_rows]
    45        80     191147.0   2389.3      0.0      append_cols = [l.append for l in coo_cols]
    46                                           
    47                                               # Store variables once instead of recalculating
    48        80     145500.0   1818.8      0.0      Y_limit = C.Y - 1
    49        80     173316.0   2166.4      0.0      G_limit = (C.G - 1) / 2
    50        80      59999.0    750.0      0.0      X, D_min = C.X, C.D_min
    51        80      76792.0    959.9      0.0      V_max, g = C.V_max, C.g
    52        80      68395.0    854.9      0.0      S_h, S_h_0 = C.S_h, C.S_h[0]
    53        80      74184.0    927.3      0.0      p_height = 1 / len(S_h)
    54        80      88509.0   1106.4      0.0      U_strong_prob = 1 / (2 * C.V_dev + 1)
    55        80     496915.0   6211.4      0.0      W_v = C.W_v
    56                                           
    57        80      42539.0    531.7      0.0      U = [
    58        80      59795.0    747.4      0.0          [0, C.U_no_flap, 1, [0]],
    59        80      57449.0    718.1      0.0          [1, C.U_weak, 1, [0]],
    60        80      50351.0    629.4      0.0          [2, C.U_strong, U_strong_prob, W_v]
    61                                               ]
    62                                           
    63        80     464058.0   5800.7      0.0      max_v = V_max + max(C.input_space) + max(W_v) - g
    64        80     206470.0   2580.9      0.0      min_v = -V_max + min(C.input_space) + min(W_v) - g
    65                                           
    66        80    1161806.0  14522.6      0.0      Y_LOOKUP = {y_v: min(Y_limit, max(0, y_v)) for y_v in range(0-V_max, Y_limit+V_max+1)}
    67                                           
    68        80     735374.0   9192.2      0.0      V_LOOKUP = {(v+g): min(V_max, max(-V_max, v)) for v in range(min_v, max_v+1)}
    69                                           
    70    118880   69176539.0    581.9      2.4      for (y_i, v_i, d_i), h_i, state_index, m_min in valid_states_with_indices:
    71    118800   47122343.0    396.7      1.6          y_j = Y_LOOKUP[y_i + v_i]
    72    118800   46268896.0    389.5      1.6          if d_i[0] == 0: # Passing
    73     36000   20002874.0    555.6      0.7              if abs(y_i - h_i[0]) > G_limit:
    74     31600    8896108.0    281.5      0.3                  continue # Crash!
    75      4400    3648093.0    829.1      0.1              dhat_j = (d_i[1] - 1, *d_i[2:], 0)
    76      4400    2522420.0    573.3      0.1              hhat_j = (*h_i[1:], S_h_0)
    77                                           
    78                                                       # We need to update m_min!
    79      4400    3723325.0    846.2      0.1              m_min = dhat_j[1:].index(0) + 1
    80                                                   else:
    81     82800   57228135.0    691.2      2.0              dhat_j = (d_i[0] - 1, *d_i[1:])
    82     82800   23254452.0    280.9      0.8              hhat_j = h_i
    83                                           
    84     87200   51103162.0    586.0      1.8          s = X - 1 - sum(dhat_j)
    85                                           
    86     87200   28802674.0    330.3      1.0          if s < D_min:
    87     68400   20067429.0    293.4      0.7              p_spawn = 0
    88     68400   21335243.0    311.9      0.7              p_no_spawn = 1
    89     18800    6985098.0    371.5      0.2          elif s >= X - 1:
    90      5040    1659494.0    329.3      0.1              p_spawn = 1
    91      5040    1574032.0    312.3      0.1              p_no_spawn = 0
    92                                                   else:
    93     13760    7314490.0    531.6      0.3              p_spawn = (s - (D_min - 1)) / (X - D_min)
    94     13760    6580114.0    478.2      0.2              p_no_spawn = 1 - p_spawn
    95                                           
    96     87200   30077416.0    344.9      1.0          if p_spawn > 0:
    97     18800   31153297.0   1657.1      1.1              spawn_array = state_to_index_array[y_j, :, *dhat_j[:m_min], s, *dhat_j[m_min+1:], *hhat_j[:m_min], :, *hhat_j[m_min+1:]]
    98                                           
    99     87200   27985574.0    320.9      1.0          if p_no_spawn > 0:
   100     82160   74741488.0    909.7      2.6              no_spawn_array = state_to_index_array[y_j, :, *dhat_j, *hhat_j]
   101                                           
   102                                                   # Each input will push to a seperate index in coo_*
   103                                                   # Important note: Duplicate entries will be SUMMED!
   104                                                   # This means that we do not have to worry about two inputs resulting in the same next_state (See += in compute_transition_probabilities)
   105     87200   32535512.0    373.1      1.1          p_b = p_spawn * p_height
   106    348800  137301267.0    393.6      4.8          for input_index, u_k, p_flap, W_v_list in U:
   107    261600   86924581.0    332.3      3.0              p_a = p_flap * p_no_spawn
   108    261600   81916145.0    313.1      2.8              p_b = p_flap * p_b
   109    697600  210845574.0    302.2      7.3              for w_v in W_v_list:
   110    436000  163592730.0    375.2      5.7                  v_j = V_LOOKUP[v_i + u_k + w_v]
   111                                           
   112                                                           # Case 1: No spawn
   113    436000  130448148.0    299.2      4.5                  if p_no_spawn > 0:
   114    410800  173802796.0    423.1      6.0                      j_index = no_spawn_array[v_j]
   115                                           
   116    410800  150828154.0    367.2      5.2                      append_data[input_index](p_a)
   117    410800  150234477.0    365.7      5.2                      append_rows[input_index](state_index)
   118    410800  146737248.0    357.2      5.1                      append_cols[input_index](j_index)
   119                                           
   120                                                           # Case 2: Spawn
   121    436000  145637747.0    334.0      5.1                  if p_spawn > 0:
   122    282000   87536991.0    310.4      3.0                      for height in S_h:
   123    188000   93345652.0    496.5      3.2                          j_index = spawn_array[v_j, height]
   124                                           
   125    188000   66840134.0    355.5      2.3                          append_data[input_index](p_b)
   126    188000   66103513.0    351.6      2.3                          append_rows[input_index](state_index)
   127    188000   70967155.0    377.5      2.5                          append_cols[input_index](j_index)
   128                                           
   129                                               # Construct the sparse matrices
   130        80      39558.0    494.5      0.0      P_sparse_list = []
   131       320    1245881.0   3893.4      0.0      for l in range(C.L):
   132                                                   # Build as COO first (fastest for this input)
   133       480  227054202.0 473029.6      7.9          P_l_coo = coo_matrix(
   134       240     195468.0    814.5      0.0              (coo_data[l], (coo_rows[l], coo_cols[l])),
   135       240      86159.0    359.0      0.0              shape=(K, K)
   136                                                   )
   137                                                   # Convert to CSC (fast, sums duplicates)
   138       240   53305012.0 222104.2      1.9          P_l = P_l_coo.tocsc()
   139       240     269532.0   1123.0      0.0          P_sparse_list.append(P_l)
   140                                           
   141        80      23608.0    295.1      0.0      return P_sparse_list

Total time: 4.09346 s
Average time: 0.102337 s
File: /home/gblum/dev/dpc/Solver.py
Function: solution_linear_prog_sparse at line 107

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   107                                           def solution_linear_prog_sparse(C: Const) -> tuple[np.array, np.array]:
   108                                               """Computes the optimal cost and the optimal control policy.
   109                                           
   110                                               You can solve the SSP by any method:
   111                                               - Value Iteration
   112                                               - Policy Iteration
   113                                               - Linear Programming
   114                                               - A combination of the above
   115                                               - Others?
   116                                           
   117                                               Args:
   118                                                   C (Const): The constants describing the problem instance.
   119                                           
   120                                               Returns:
   121                                                   np.array: The optimal cost to go for the stochastic SPP,
   122                                                       of shape (C.K,), where C.K is the number of states.
   123                                                   np.array: The optimal control policy for the stochastic SPP,
   124                                                       of shape (C.K,), where each entry is in {0,...,C.L-1}.
   125                                               """
   126        40     113980.0   2849.5      0.0      ss = CustomStateSpace()
   127        40  599374634.0  1.5e+07     14.6      K, state_array, valid_states = ss.custom_state_space(C)
   128                                           
   129        40     535396.0  13384.9      0.0      J_opt = np.zeros(K)
   130        40     104375.0   2609.4      0.0      u_opt = np.zeros(K)
   131                                           
   132        40 2446649356.0 6.12e+07     59.8      P = compute_transition_probabilities(C, state_array, K, valid_states)
   133        40    2647250.0  66181.2      0.1      Q, b = compute_expected_stage_cost(C, K)
   134                                           
   135        40     456503.0  11412.6      0.0      c = np.full(K, -1, np.int64)
   136                                           
   137                                               # 1. Create a sparse identity matrix
   138        40    5968266.0 149206.6      0.1      I_sparse = eye(K, format='csc')
   139                                           
   140                                               # 2. Create a list to hold the sparse blocks (I - P_l)
   141        40      21034.0    525.9      0.0      A_blocks = []
   142                                           
   143                                               # 3. Loop over all actions
   144       160     232806.0   1455.0      0.0      for l in range(C.L):
   145                                                   # Add the sparse (I - P_l) block to our list
   146       120   33498198.0 279151.7      0.8          A_blocks.append(I_sparse - P[l])
   147                                           
   148                                               # 4. Stack all blocks vertically into one sparse matrix
   149        40   19385830.0 484645.8      0.5      A = vstack(A_blocks, format='csc')
   150                                           
   151                                               # 'highs' is the best for sparse problems
   152        40  975241532.0 2.44e+07     23.8      res = linprog(c, A_ub=A, b_ub=b, bounds=[None, 0], method='highs')
   153                                           
   154        40     266059.0   6651.5      0.0      J_opt = res.x
   155                                           
   156                                               # Create a list of weighted_J vectors, one for each action l
   157        40      21269.0    531.7      0.0      weighted_J_cols = []
   158       160     462749.0   2892.2      0.0      for l in range(C.L):
   159                                                   # P[l] is (K, K) sparse, J_opt is (K,) dense
   160                                                   # The @ operator performs efficient sparse-dot-dense
   161       120    4375740.0  36464.5      0.1          weighted_J_l = P[l] @ J_opt  # Result is a (K,) dense vector
   162       120      93156.0    776.3      0.0          weighted_J_cols.append(weighted_J_l)
   163                                           
   164                                               # Stack the (K,) vectors as columns into a (K, L) dense array
   165        40    1720066.0  43001.7      0.0      weighted_J_all = np.stack(weighted_J_cols, axis=1)
   166        40     893537.0  22338.4      0.0      expected_values = Q + weighted_J_all
   167                                           
   168        40    1027874.0  25696.8      0.0      optimal_indices = np.argmin(expected_values, axis=1)
   169        40     358356.0   8958.9      0.0      u_opt = np.array(C.input_space)[optimal_indices]
   170                                           
   171        40      16525.0    413.1      0.0      return J_opt, u_opt

Total time: 24.784 s
Average time: 24.784 s
File: /home/gblum/dev/dpc/env/lib/python3.11/timeit.py
Function: Timer.timeit at line 166

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   166                                               def timeit(self, number=default_number):
   167                                                   """Time 'number' executions of the main statement.
   168                                           
   169                                                   To be precise, this executes the setup statement once, and
   170                                                   then returns the time it takes to execute the main statement
   171                                                   a number of times, as float seconds if using the default timer.   The
   172                                                   argument is the number of times through the loop, defaulting
   173                                                   to one million.  The main statement, the setup statement and
   174                                                   the timer function to be used are passed to the constructor.
   175                                                   """
   176         1       2260.0   2260.0      0.0          it = itertools.repeat(None, number)
   177         1        953.0    953.0      0.0          gcold = gc.isenabled()
   178         1        642.0    642.0      0.0          gc.disable()
   179         1        228.0    228.0      0.0          try:
   180         1     2.48e+10 2.48e+10    100.0              timing = self.inner(it, self.timer)
   181                                                   finally:
   182         1        439.0    439.0      0.0              if gcold:
   183         1    1593746.0 1.59e+06      0.0                  gc.enable()
   184         1       4336.0   4336.0      0.0          return timing

Total time: 0.650169 s
Average time: 1.08145e-05 s
File: /home/gblum/dev/dpc/utils.py
Function: CustomStateSpace.build_d_recursive at line 84

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    84                                               def build_d_recursive(self, y, v, current_d_list, current_d_sum, d_index, spot0):
    85                                                   """
    86                                                   Recursively builds the D-vector (d1, ..., dM) for a given
    87                                                   (y, v) prefix.
    88                                           
    89                                                   Pruning:
    90                                                   - sum(d) > X-1
    91                                                   - Trailing zeros (if d_i=0, all d_j for j>i must be 0)
    92                                                   - d2=0 if d1=0
    93                                                   """
    94                                                   # --- Base Case: D-vector is complete ---
    95     60120   23603031.0    392.6      3.6          if d_index == self.M:
    96                                                       # D-vector is built, now start building the H-vector
    97     38160   15092561.0    395.5      2.3              h_iterable = self.possible_h_iterables[spot0]
    98                                           
    99     38160   38928419.0   1020.1      6.0              arr = self.state_to_index_array[y, v, *current_d_list, :]
   100     38160   20918342.0    548.2      3.2              pre = (y, v, current_d_list[:])
   101                                                       # 2. Loop over the product of these allowed H-options
   102    156960   49384912.0    314.6      7.6              for h_tuple in h_iterable:
   103                                                           global current_index
   104    118800   71684029.0    603.4     11.0                  arr[*h_tuple] = current_index
   105    118800   70320619.0    591.9     10.8                  self.valid_states_with_indices.append((pre, h_tuple, current_index, spot0))
   106    118800   46505848.0    391.5      7.2                  current_index += 1
   107                                           
   108     38160   11087294.0    290.5      1.7              return        # --- Recursive Step: Add d_i ---
   109                                           
   110     21960    7226361.0    329.1      1.1          if d_index == 0:
   111      2520     970283.0    385.0      0.1              d_options = self.S_d1
   112     19440    6421135.0    330.3      1.0          elif spot0 > 0:
   113                                                       d_options = self.S_d0
   114                                                   else:
   115     19440    6385542.0    328.5      1.0              d_options = self.S_d
   116                                           
   117     82080   25503432.0    310.7      3.9          for d in d_options:
   118                                                       # 1. Sum constraint
   119     77040   32539754.0    422.4      5.0              if current_d_sum + d > self.X_limit:
   120     16920    5386564.0    318.4      0.8                  break # These are stored in increasing order
   121                                           
   122                                                       # 3. d1/d2 constraint (d1=0 -> d2>0)
   123                                                       # d_index == 1 is d2
   124     60120   18856459.0    313.6      2.9              if d_index == 1:
   125     40680   13986894.0    343.8      2.2                  d1 = current_d_list[0]
   126     40680   13560274.0    333.3      2.1                  if d1 == 0 and d == 0:
   127      2520     718521.0    285.1      0.1                      continue
   128                                           
   129     57600   23902086.0    415.0      3.7              if spot0 == 0 and d_index > 0 and d == 0:
   130     16920    5783850.0    341.8      0.9                  current_d_list[d_index] = d
   131     33840   12288136.0    363.1      1.9                  self.build_d_recursive(
   132     16920    5074705.0    299.9      0.8                      y, v,
   133     16920    4677180.0    276.4      0.7                      current_d_list,
   134     16920    5683008.0    335.9      0.9                      current_d_sum + d,
   135     16920    5384284.0    318.2      0.8                      d_index + 1,
   136     16920    4317294.0    255.2      0.7                      d_index # This is the first zero
   137                                                           )
   138                                                       else:
   139     40680   14545163.0    357.6      2.2                  current_d_list[d_index] = d
   140     81360   30367422.0    373.2      4.7                  self.build_d_recursive(
   141     40680   11820651.0    290.6      1.8                      y, v,
   142     40680   10731807.0    263.8      1.7                      current_d_list,
   143     40680   12513442.0    307.6      1.9                      current_d_sum + d,
   144     40680   13001073.0    319.6      2.0                      d_index + 1,
   145     40680   10998860.0    270.4      1.7                      spot0 # Zero spot unchanged
   146                                                           )

Total time: 1.21119 s
Average time: 0.0151398 s
File: /home/gblum/dev/dpc/utils.py
Function: CustomStateSpace.custom_state_space at line 148

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   148                                               def custom_state_space(self, C: Const) -> Tuple[int, np.ndarray, list]:
   149                                                   """
   150                                                   Computes the state space and returns a state -> index dictionary
   151                                                   using a recursive, pruning-based generation method.
   152                                           
   153                                                   This function maintains the strict lexicographical ordering
   154                                                   from the problem statement, ensuring the state-to-index
   155                                                   mapping is identical to the original 'itertools.product' method,
   156                                                   but is significantly faster by pruning invalid branches early.
   157                                                   """
   158                                                   global current_index
   159        80     128780.0   1609.8      0.0          current_index = 0
   160                                           
   161        80      82352.0   1029.4      0.0          self.valid_states_with_indices = []
   162                                           
   163                                                   # --- Cache constants from C for minor speedup ---
   164        80     560301.0   7003.8      0.0          self.S_y, self.S_v = C.S_y, C.S_v
   165        80     612539.0   7656.7      0.1          self.S_d, self.S_d1 = sorted(C.S_d), sorted(C.S_d1)
   166        80     103816.0   1297.7      0.0          self.S_h, self.S_h_default = C.S_h, C.S_h[0]
   167        80     342816.0   4285.2      0.0          self.M, self.X_limit = C.M, C.X - 1
   168                                           
   169                                                   # --- Create mappings for non-contiguous state variables ---
   170        80      75679.0    946.0      0.0          self.v_offset = C.V_max
   171                                           
   172                                                   # --- Initialize state_to_index_array ---
   173        80      73626.0    920.3      0.0          dims = [C.Y, self.v_offset + 2 * C.V_max + 1]
   174       240     130432.0    543.5      0.0          for _ in range(self.M):
   175       160     110072.0    688.0      0.0              dims.append(C.X) # d values are 0..X-1
   176       240     103837.0    432.7      0.0          for _ in range(self.M):
   177       160      69860.0    436.6      0.0              dims.append(C.Y) # h values are 0..Y-1
   178                                           
   179        80   10614507.0 132681.3      0.9          self.state_to_index_array = np.full(dims, -1, dtype=np.int32)
   180                                           
   181                                           
   182                                                   # Pre-build the two possible lists for H-options
   183        80      72183.0    902.3      0.0          self.h_options_all = self.S_h
   184        80      62740.0    784.2      0.0          self.h_options_default = [self.S_h_default]
   185                                           
   186                                                   # Pre build an empty D-options list
   187        80      48430.0    605.4      0.0          self.S_d0 = [0]
   188                                           
   189        80     368790.0   4609.9      0.0          possible_h_iterables = [[self.h_options_all] + [self.h_options_all for i in range(1, self.M)]]
   190       160      88575.0    553.6      0.0          for spot0 in range(1, self.M):
   191       160     407567.0   2547.3      0.0              possible_h_iterables.append([self.h_options_all] + [
   192                                                           self.h_options_default if i >= spot0 else self.h_options_all
   193        80      40767.0    509.6      0.0                  for i in range(1, self.M)
   194                                                       ])
   195        80     476642.0   5958.0      0.0          self.possible_h_iterables = [list(product(*h_iter)) for h_iter in possible_h_iterables]
   196                                           
   197                                                   # The outer loops *must* be y, then v, to maintain order
   198       680     353816.0    520.3      0.0          for y in self.S_y:
   199      3120    1550353.0    496.9      0.1              for v in self.S_v:
   200      2520    2104156.0    835.0      0.2                  current_d_list_for_v = [0] * self.M
   201                                                           # Start the recursion for the D-vector
   202      2520 1192511471.0 473218.8     98.5                  self.build_d_recursive(y, v, current_d_list_for_v, 0, 0, 0)
   203                                           
   204        80      92073.0   1150.9      0.0          return current_index, self.state_to_index_array, self.valid_states_with_indices


Timer unit: 1e-09 s

Total time: 0.000930499 s
Average time: 2.90781e-05 s
File: /home/gblum/dev/dpc/ComputeExpectedStageCosts.py
Function: compute_expected_stage_cost_solver at line 23

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    23                                           def compute_expected_stage_cost_solver(C: Const, K: int) -> Tuple[np.array, np.array]:
    24        32      72373.0   2261.7      7.8      costs_row = np.array([
    25        16       7069.0    441.8      0.8          -1,                # Cost for action 0 (None)
    26        16      19905.0   1244.1      2.1          C.lam_weak - 1,    # Cost for action 1 (Weak)
    27        16       8928.0    558.0      1.0          C.lam_strong - 1   # Cost for action 2 (Strong)
    28                                               ])
    29                                           
    30        32     167448.0   5232.8     18.0      b = np.concatenate((
    31        16     296632.0  18539.5     31.9          np.repeat(costs_row[0], K),  # Column 0 of Q
    32        16     128620.0   8038.8     13.8          np.repeat(costs_row[1], K),  # Column 1 of Q
    33        16     103783.0   6486.4     11.2          np.repeat(costs_row[2], K)   # Column 2 of Q
    34                                               ))
    35                                           
    36        16     119564.0   7472.8     12.8      Q = b.reshape((K, C.L), order='F')
    37                                           
    38        16       6177.0    386.1      0.7      return Q, b

Total time: 1.08167 s
Average time: 0.0338022 s
File: /home/gblum/dev/dpc/ComputeTransitionProbabilities.py
Function: compute_transition_probabilities_sparse at line 28

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    28                                           def compute_transition_probabilities_sparse(C:Const, state_to_index_array, K, valid_states_with_indices) -> list:
    29                                               """Computes the transition probability matrix P as a list of sparse matrices."""
    30                                           
    31                                               # Each action in C.input_space will have its own sparse probability matrix
    32        32     207196.0   6474.9      0.0      num_inputs = len(C.input_space)
    33                                           
    34                                               # A calculated probability P[curr_state, next_state, action] is stored as
    35                                               #   coo_data[action] = P[curr_state, next_state, action]
    36                                               #   coo_cols[action] = curr_state
    37                                               #   coo_rows[action] = next_state
    38        32     203856.0   6370.5      0.0      coo_data = [[] for input_i in range(num_inputs)]
    39        32      77083.0   2408.8      0.0      coo_cols = [[] for input_i in range(num_inputs)]
    40        32      83882.0   2621.3      0.0      coo_rows = [[] for input_i in range(num_inputs)]
    41                                           
    42                                               # Helper functions for populating coo table
    43        32      97562.0   3048.8      0.0      append_data = [l.append for l in coo_data]
    44        32      87523.0   2735.1      0.0      append_rows = [l.append for l in coo_rows]
    45        32      63432.0   1982.2      0.0      append_cols = [l.append for l in coo_cols]
    46                                           
    47                                               # Store variables once instead of recalculating
    48        32      32760.0   1023.8      0.0      Y_limit = C.Y - 1
    49        32      45065.0   1408.3      0.0      G_limit = (C.G - 1) / 2
    50        32     132402.0   4137.6      0.0      M = C.M
    51        32      14502.0    453.2      0.0      X, D_min = C.X, C.D_min
    52        32      22970.0    717.8      0.0      V_max, g = C.V_max, C.g
    53        32      20300.0    634.4      0.0      S_h, S_h_0 = C.S_h, C.S_h[0]
    54        32      20251.0    632.8      0.0      p_height = 1 / len(S_h)
    55        32      35845.0   1120.2      0.0      U_strong_prob = 1 / (2 * C.V_dev + 1)
    56        32     145328.0   4541.5      0.0      W_v = C.W_v
    57                                           
    58                                               # --- Create mappings for non-contiguous state variables ---
    59        32      12719.0    397.5      0.0      v_offset = C.V_max
    60                                           
    61        32       9399.0    293.7      0.0      StateVar_Y = 0
    62        32      11357.0    354.9      0.0      StateVar_V = 1
    63        32      11797.0    368.7      0.0      StateVar_D_1 = 2
    64        32      13831.0    432.2      0.0      StateVar_D_2 = StateVar_D_1 + 1
    65        32      14931.0    466.6      0.0      StateVar_D_M = StateVar_D_1 + M - 1
    66        32       9173.0    286.7      0.0      StateVar_H_1 = StateVar_D_M + 1
    67        32      12375.0    386.7      0.0      StateVar_H_2 = StateVar_H_1 + 1
    68        32      12273.0    383.5      0.0      StateVar_H_M = StateVar_H_1 + M - 1
    69                                           
    70        32      15602.0    487.6      0.0      U = [
    71        32      21923.0    685.1      0.0          [0, C.U_no_flap, 1, [0]],
    72        32      21728.0    679.0      0.0          [1, C.U_weak, 1, [0]],
    73        32      17847.0    557.7      0.0          [2, C.U_strong, U_strong_prob, W_v]
    74                                               ]
    75                                           
    76        32     131523.0   4110.1      0.0      max_v = V_max + max(C.input_space) + max(W_v) - g
    77        32      60623.0   1894.5      0.0      min_v = -V_max + min(C.input_space) + min(W_v) - g
    78                                           
    79        32     382399.0  11950.0      0.0      Y_LOOKUP = {y_v: min(Y_limit, max(0, y_v)) for y_v in range(0-V_max, Y_limit+V_max+1)}
    80                                           
    81        32     256055.0   8001.7      0.0      V_LOOKUP = {(v+g): min(V_max, max(-V_max, v)) for v in range(min_v, max_v+1)}
    82                                           
    83     47552   24468341.0    514.6      2.3      for y_i, v_i, d_i, h_i, state_index, m_min in valid_states_with_indices:
    84     47520   16593236.0    349.2      1.5          y_j = Y_LOOKUP[y_i + v_i]
    85     47520   17176098.0    361.4      1.6          if d_i[0] == 0: # Passing
    86     14400    7457039.0    517.8      0.7              if abs(y_i - h_i[0]) > G_limit:
    87     12640    3054334.0    241.6      0.3                  continue # Crash!
    88      1760    1297805.0    737.4      0.1              dhat_j = (d_i[1] - 1, *d_i[2:], 0)
    89      1760     909453.0    516.7      0.1              hhat_j = (*h_i[1:], S_h_0) #TODO: Remove expansion
    90                                           
    91                                                       # We need to update m_min!
    92      1760    1388401.0    788.9      0.1              m_min = dhat_j[1:].index(0) + 1
    93                                                   else:
    94     33120   21788235.0    657.9      2.0              dhat_j = (d_i[0] - 1, *d_i[1:]) #TODO: Remove expansion
    95     33120    7989458.0    241.2      0.7              hhat_j = h_i
    96                                           
    97     34880   18027962.0    516.9      1.7          s = X - 1 - sum(dhat_j)
    98                                           
    99     34880   10536793.0    302.1      1.0          if s < D_min:
   100     27360    7191522.0    262.8      0.7              p_spawn = 0
   101     27360    7742648.0    283.0      0.7              p_no_spawn = 1
   102      7520    2602954.0    346.1      0.2          elif s >= X - 1:
   103      2016     524910.0    260.4      0.0              p_spawn = 1
   104      2016     581715.0    288.5      0.1              p_no_spawn = 0
   105                                                   else:
   106      5504    2709542.0    492.3      0.3              p_spawn = (s - (D_min - 1)) / (X - D_min)
   107      5504    2301177.0    418.1      0.2              p_no_spawn = 1 - p_spawn
   108                                           
   109     34880   11308723.0    324.2      1.0          if p_spawn > 0:
   110      7520   11786487.0   1567.4      1.1              spawn_array = state_to_index_array[y_j, :, *dhat_j[:m_min], s, *dhat_j[m_min+1:], *hhat_j[:m_min], :, *hhat_j[m_min+1:]]
   111                                           
   112     34880    9750142.0    279.5      0.9          if p_no_spawn > 0:
   113     32864   27857285.0    847.7      2.6              no_spawn_array = state_to_index_array[y_j, :, *dhat_j, *hhat_j]
   114                                           
   115                                                   # Each input will push to a seperate index in coo_*
   116                                                   # Important note: Duplicate entries will be SUMMED!
   117                                                   # This means that we do not have to worry about two inputs resulting in the same next_state (See += in compute_transition_probabilities)
   118     34880   11810875.0    338.6      1.1          p_b = p_spawn * p_height
   119    139520   47920529.0    343.5      4.4          for input_index, u_k, p_flap, W_v_list in U:
   120    104640   30509668.0    291.6      2.8              p_a = p_flap * p_no_spawn
   121    104640   29101888.0    278.1      2.7              p_b = p_flap * p_b
   122    279040   81476886.0    292.0      7.5              for w_v in W_v_list:
   123    174400   60325777.0    345.9      5.6                  v_j = V_LOOKUP[v_i + u_k + w_v]
   124                                           
   125                                                           # Case 1: No spawn
   126    174400   49485028.0    283.7      4.6                  if p_no_spawn > 0:
   127    164320   68655463.0    417.8      6.3                      j_index = no_spawn_array[v_j]
   128                                           
   129    164320   61728643.0    375.7      5.7                      append_data[input_index](p_a)
   130    164320   56712759.0    345.1      5.2                      append_rows[input_index](state_index)
   131    164320   56425102.0    343.4      5.2                      append_cols[input_index](j_index)
   132                                           
   133                                                           # Case 2: Spawn
   134    174400   53405915.0    306.2      4.9                  if p_spawn > 0:
   135    112800   33112326.0    293.5      3.1                      for height in S_h:
   136     75200   36612840.0    486.9      3.4                          j_index = spawn_array[v_j, height]
   137                                           
   138     75200   25938872.0    344.9      2.4                          append_data[input_index](p_b)
   139     75200   25605268.0    340.5      2.4                          append_rows[input_index](state_index)
   140     75200   26715582.0    355.3      2.5                          append_cols[input_index](j_index)
   141                                           
   142                                               # Construct the sparse matrices
   143        32      14669.0    458.4      0.0      P_sparse_list = []
   144       128     475121.0   3711.9      0.0      for l in range(C.L):
   145                                                   # Build as COO first (fastest for this input)
   146       192   86687278.0 451496.2      8.0          P_l_coo = coo_matrix(
   147        96      82807.0    862.6      0.0              (coo_data[l], (coo_rows[l], coo_cols[l])),
   148        96      32678.0    340.4      0.0              shape=(K, K)
   149                                                   )
   150                                                   # Convert to CSC (fast, sums duplicates)
   151        96   21370012.0 222604.3      2.0          P_l = P_l_coo.tocsc()
   152        96     105785.0   1101.9      0.0          P_sparse_list.append(P_l)
   153                                           
   154        32       9006.0    281.4      0.0      return P_sparse_list

Total time: 1.54634 s
Average time: 0.0966465 s
File: /home/gblum/dev/dpc/Solver.py
Function: solution_linear_prog_sparse at line 107

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   107                                           def solution_linear_prog_sparse(C: Const) -> tuple[np.array, np.array]:
   108                                               """Computes the optimal cost and the optimal control policy.
   109                                           
   110                                               You can solve the SSP by any method:
   111                                               - Value Iteration
   112                                               - Policy Iteration
   113                                               - Linear Programming
   114                                               - A combination of the above
   115                                               - Others?
   116                                           
   117                                               Args:
   118                                                   C (Const): The constants describing the problem instance.
   119                                           
   120                                               Returns:
   121                                                   np.array: The optimal cost to go for the stochastic SPP,
   122                                                       of shape (C.K,), where C.K is the number of states.
   123                                                   np.array: The optimal control policy for the stochastic SPP,
   124                                                       of shape (C.K,), where each entry is in {0,...,C.L-1}.
   125                                               """
   126        16      55714.0   3482.1      0.0      ss = CustomStateSpace()
   127        16  233063707.0 1.46e+07     15.1      K, state_array, valid_states = ss.custom_state_space(C)
   128                                           
   129        16     179065.0  11191.6      0.0      J_opt = np.zeros(K)
   130        16      28498.0   1781.1      0.0      u_opt = np.zeros(K)
   131                                           
   132        16  925096510.0 5.78e+07     59.8      P = compute_transition_probabilities(C, state_array, K, valid_states)
   133        16    1121516.0  70094.8      0.1      Q, b = compute_expected_stage_cost(C, K)
   134                                           
   135        16     227637.0  14227.3      0.0      c = np.full(K, -1, np.int64)
   136                                           
   137                                               # 1. Create a sparse identity matrix
   138        16    2347000.0 146687.5      0.2      I_sparse = eye(K, format='csc')
   139                                           
   140                                               # 2. Create a list to hold the sparse blocks (I - P_l)
   141        16       8266.0    516.6      0.0      A_blocks = []
   142                                           
   143                                               # 3. Loop over all actions
   144        64      92440.0   1444.4      0.0      for l in range(C.L):
   145                                                   # Add the sparse (I - P_l) block to our list
   146        48   13261614.0 276283.6      0.9          A_blocks.append(I_sparse - P[l])
   147                                           
   148                                               # 4. Stack all blocks vertically into one sparse matrix
   149        16    7656155.0 478509.7      0.5      A = vstack(A_blocks, format='csc')
   150                                           
   151                                               # 'highs' is the best for sparse problems
   152        16  359289931.0 2.25e+07     23.2      res = linprog(c, A_ub=A, b_ub=b, bounds=[None, 0], method='highs')
   153                                           
   154        16     104124.0   6507.8      0.0      J_opt = res.x
   155                                           
   156                                               # Create a list of weighted_J vectors, one for each action l
   157        16       7195.0    449.7      0.0      weighted_J_cols = []
   158        64     169457.0   2647.8      0.0      for l in range(C.L):
   159                                                   # P[l] is (K, K) sparse, J_opt is (K,) dense
   160                                                   # The @ operator performs efficient sparse-dot-dense
   161        48    1876459.0  39092.9      0.1          weighted_J_l = P[l] @ J_opt  # Result is a (K,) dense vector
   162        48      38630.0    804.8      0.0          weighted_J_cols.append(weighted_J_l)
   163                                           
   164                                               # Stack the (K,) vectors as columns into a (K, L) dense array
   165        16     748869.0  46804.3      0.0      weighted_J_all = np.stack(weighted_J_cols, axis=1)
   166        16     449450.0  28090.6      0.0      expected_values = Q + weighted_J_all
   167                                           
   168        16     379189.0  23699.3      0.0      optimal_indices = np.argmin(expected_values, axis=1)
   169        16     136319.0   8519.9      0.0      u_opt = np.array(C.input_space)[optimal_indices]
   170                                           
   171        16       6740.0    421.2      0.0      return J_opt, u_opt

Total time: 9.70176 s
Average time: 9.70176 s
File: /home/gblum/dev/dpc/env/lib/python3.11/timeit.py
Function: Timer.timeit at line 166

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   166                                               def timeit(self, number=default_number):
   167                                                   """Time 'number' executions of the main statement.
   168                                           
   169                                                   To be precise, this executes the setup statement once, and
   170                                                   then returns the time it takes to execute the main statement
   171                                                   a number of times, as float seconds if using the default timer.   The
   172                                                   argument is the number of times through the loop, defaulting
   173                                                   to one million.  The main statement, the setup statement and
   174                                                   the timer function to be used are passed to the constructor.
   175                                                   """
   176         1       2753.0   2753.0      0.0          it = itertools.repeat(None, number)
   177         1       1522.0   1522.0      0.0          gcold = gc.isenabled()
   178         1        893.0    893.0      0.0          gc.disable()
   179         1        451.0    451.0      0.0          try:
   180         1 9700926579.0  9.7e+09    100.0              timing = self.inner(it, self.timer)
   181                                                   finally:
   182         1        364.0    364.0      0.0              if gcold:
   183         1     821875.0 821875.0      0.0                  gc.enable()
   184         1        968.0    968.0      0.0          return timing

Total time: 0.24883 s
Average time: 1.03472e-05 s
File: /home/gblum/dev/dpc/utils.py
Function: CustomStateSpace.build_d_recursive at line 84

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    84                                               def build_d_recursive(self, y, v, current_d_list, current_d_sum, d_index, spot0):
    85                                                   """
    86                                                   Recursively builds the D-vector (d1, ..., dM) for a given
    87                                                   (y, v) prefix.
    88                                           
    89                                                   Pruning:
    90                                                   - sum(d) > X-1
    91                                                   - Trailing zeros (if d_i=0, all d_j for j>i must be 0)
    92                                                   - d2=0 if d1=0
    93                                                   """
    94                                                   # --- Base Case: D-vector is complete ---
    95     24048    8225330.0    342.0      3.3          if d_index == self.M:
    96                                                       # D-vector is built, now start building the H-vector
    97     15264    5425139.0    355.4      2.2              h_iterable = self.possible_h_iterables[spot0]
    98                                           
    99                                                       # 2. Loop over the product of these allowed H-options
   100     15264    8002474.0    524.3      3.2              prefix = (y, v) + tuple(current_d_list)
   101     62784   18130447.0    288.8      7.3              for h_tuple in h_iterable:
   102     47520   35821752.0    753.8     14.4                  self.state_to_index_array[*prefix, *h_tuple] = self.current_index
   103     47520   29913148.0    629.5     12.0                  self.valid_states_with_indices.append((y, v, current_d_list[:], h_tuple, self.current_index, spot0))
   104     47520   18030393.0    379.4      7.2                  self.current_index += 1
   105                                           
   106     15264    4235432.0    277.5      1.7              return        # --- Recursive Step: Add d_i ---
   107      8784    2750430.0    313.1      1.1          if d_index == 0:
   108      1008     368572.0    365.6      0.1              d_options = self.S_d1
   109      7776    2235272.0    287.5      0.9          elif spot0 > 0:
   110                                                       d_options = self.S_d0
   111                                                   else:
   112      7776    2274511.0    292.5      0.9              d_options = self.S_d
   113                                           
   114     32832    9401614.0    286.4      3.8          for d in d_options:
   115                                                       # 1. Sum constraint
   116     30816   11461063.0    371.9      4.6              if current_d_sum + d > self.X_limit:
   117      6768    2049182.0    302.8      0.8                  break # These are stored in increasing order
   118                                           
   119                                                       # 3. d1/d2 constraint (d1=0 -> d2>0)
   120                                                       # d_index == 1 is d2
   121     24048    7312910.0    304.1      2.9              if d_index == 1:
   122     16272    4908087.0    301.6      2.0                  d1 = current_d_list[0]
   123     16272    4280758.0    263.1      1.7                  d2 = d
   124     16272    5030598.0    309.2      2.0                  if d1 <= 0 and d2 == 0:
   125      1008     276521.0    274.3      0.1                      continue
   126                                           
   127     23040    6548632.0    284.2      2.6              next_spot0 = spot0
   128     23040    8227525.0    357.1      3.3              if spot0 == 0 and d_index > 0 and d == 0:
   129      6768    1745325.0    257.9      0.7                  next_spot0 = d_index  # This is the first zero
   130                                           
   131                                                       # Recurse with the added d
   132     23040    7154174.0    310.5      2.9              current_d_list[d_index] = d
   133     46080   15067620.0    327.0      6.1              self.build_d_recursive(
   134     23040    6071121.0    263.5      2.4                  y, v,
   135     23040    5564154.0    241.5      2.2                  current_d_list,
   136     23040    6305442.0    273.7      2.5                  current_d_sum + d,
   137     23040    6962500.0    302.2      2.8                  d_index + 1,
   138     23040    5049483.0    219.2      2.0                  next_spot0
   139                                                       )

Total time: 0.459856 s
Average time: 0.0143705 s
File: /home/gblum/dev/dpc/utils.py
Function: CustomStateSpace.custom_state_space at line 141

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   141                                               def custom_state_space(self, C: Const) -> Tuple[int, np.ndarray, list]:
   142                                                   """
   143                                                   Computes the state space and returns a state -> index dictionary
   144                                                   using a recursive, pruning-based generation method.
   145                                           
   146                                                   This function maintains the strict lexicographical ordering
   147                                                   from the problem statement, ensuring the state-to-index
   148                                                   mapping is identical to the original 'itertools.product' method,
   149                                                   but is significantly faster by pruning invalid branches early.
   150                                                   """
   151                                           
   152                                           
   153        32      46372.0   1449.1      0.0          self.current_index = 0
   154        32      27880.0    871.2      0.0          self.valid_states_with_indices = []
   155                                           
   156                                                   # --- Cache constants from C for minor speedup ---
   157        32     278836.0   8713.6      0.1          self.S_y, self.S_v = C.S_y, C.S_v
   158        32     203538.0   6360.6      0.0          self.S_d, self.S_d1 = C.S_d, C.S_d1
   159        32      51893.0   1621.7      0.0          self.S_h, self.S_h_default = C.S_h, C.S_h[0]
   160        32     151781.0   4743.2      0.0          self.M, self.X_limit = C.M, C.X - 1
   161                                           
   162                                                   # --- Create mappings for non-contiguous state variables ---
   163        32      19055.0    595.5      0.0          self.v_offset = C.V_max
   164                                           
   165                                                   # --- Initialize state_to_index_array ---
   166        32      24366.0    761.4      0.0          dims = [C.Y, self.v_offset + 2 * C.V_max + 1]
   167        96      59731.0    622.2      0.0          for _ in range(self.M):
   168        64      45671.0    713.6      0.0              dims.append(C.X) # d values are 0..X-1
   169        96      39534.0    411.8      0.0          for _ in range(self.M):
   170        64      35446.0    553.8      0.0              dims.append(C.Y) # h values are 0..Y-1
   171                                           
   172        32    5312128.0 166004.0      1.2          self.state_to_index_array = np.full(dims, -1, dtype=np.int32)
   173                                           
   174                                           
   175                                                   # Pre-build the two possible lists for H-options
   176        32      36497.0   1140.5      0.0          self.h_options_all = self.S_h
   177        32      31186.0    974.6      0.0          self.h_options_default = [self.S_h_default]
   178                                           
   179                                                   # Pre build an empty D-options list
   180        32      19124.0    597.6      0.0          self.S_d0 = [0]
   181                                           
   182        32     137390.0   4293.4      0.0          possible_h_iterables = [[self.h_options_all] + [self.h_options_all for i in range(1, self.M)]]
   183        64      33917.0    530.0      0.0          for spot0 in range(1, self.M):
   184        64     123965.0   1937.0      0.0              possible_h_iterables.append([self.h_options_all] + [
   185                                                           self.h_options_default if i >= spot0 else self.h_options_all
   186        32      16320.0    510.0      0.0                  for i in range(1, self.M)
   187                                                       ])
   188        32     215212.0   6725.4      0.0          self.possible_h_iterables = [list(product(*h_iter)) for h_iter in possible_h_iterables]
   189                                           
   190                                                   # The outer loops *must* be y, then v, to maintain order
   191       272     105681.0    388.5      0.0          for y in self.S_y:
   192      1248     464800.0    372.4      0.1              for v in self.S_v:
   193      1008     731664.0    725.9      0.2                  current_d_list_for_v = [0] * self.M
   194                                                           # Start the recursion for the D-vector
   195      1008  451619573.0 448035.3     98.2                  self.build_d_recursive(y, v, current_d_list_for_v, 0, 0, 0)
   196                                           
   197        32      24145.0    754.5      0.0          return self.current_index, self.state_to_index_array, self.valid_states_with_indices


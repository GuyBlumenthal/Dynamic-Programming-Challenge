Timer unit: 1e-09 s

Total time: 0.00205909 s
Average time: 2.57386e-05 s
File: /home/gblum/dev/dpc/ComputeExpectedStageCosts.py
Function: compute_expected_stage_cost_solver at line 23

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    23                                           def compute_expected_stage_cost_solver(C: Const, K: int) -> Tuple[np.array, np.array]:
    24        80     172485.0   2156.1      8.4      costs_row = np.array([
    25        40      20851.0    521.3      1.0          -1,                # Cost for action 0 (None)
    26        40      46355.0   1158.9      2.3          C.lam_weak - 1,    # Cost for action 1 (Weak)
    27        40      20326.0    508.1      1.0          C.lam_strong - 1   # Cost for action 2 (Strong)
    28                                               ])
    29                                           
    30        80     371207.0   4640.1     18.0      b = np.concatenate((
    31        40     655241.0  16381.0     31.8          np.repeat(costs_row[0], K),  # Column 0 of Q
    32        40     268003.0   6700.1     13.0          np.repeat(costs_row[1], K),  # Column 1 of Q
    33        40     232823.0   5820.6     11.3          np.repeat(costs_row[2], K)   # Column 2 of Q
    34                                               ))
    35                                           
    36        40     255477.0   6386.9     12.4      Q = b.reshape((K, C.L), order='F')
    37                                           
    38        40      16319.0    408.0      0.8      return Q, b

Total time: 2.65227 s
Average time: 0.0331534 s
File: /home/gblum/dev/dpc/ComputeTransitionProbabilities.py
Function: compute_transition_probabilities_sparse at line 28

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    28                                           def compute_transition_probabilities_sparse(C:Const, state_to_index_array, K, valid_states_with_indices) -> list:
    29                                               """Computes the transition probability matrix P as a list of sparse matrices."""
    30                                           
    31                                               # Each action in C.input_space will have its own sparse probability matrix
    32        80     467745.0   5846.8      0.0      num_inputs = len(C.input_space)
    33                                           
    34                                               # A calculated probability P[curr_state, next_state, action] is stored as
    35                                               #   coo_data[action] = P[curr_state, next_state, action]
    36                                               #   coo_cols[action] = curr_state
    37                                               #   coo_rows[action] = next_state
    38        80     455284.0   5691.1      0.0      coo_data = [[] for input_i in range(num_inputs)]
    39        80     185908.0   2323.8      0.0      coo_cols = [[] for input_i in range(num_inputs)]
    40        80     199282.0   2491.0      0.0      coo_rows = [[] for input_i in range(num_inputs)]
    41                                           
    42                                               # Helper functions for populating coo table
    43        80     219267.0   2740.8      0.0      append_data = [l.append for l in coo_data]
    44        80     174535.0   2181.7      0.0      append_rows = [l.append for l in coo_rows]
    45        80     159653.0   1995.7      0.0      append_cols = [l.append for l in coo_cols]
    46                                           
    47                                               # Store variables once instead of recalculating
    48        80      77746.0    971.8      0.0      Y_limit = C.Y - 1
    49        80     132862.0   1660.8      0.0      G_limit = (C.G - 1) / 2
    50        80      49481.0    618.5      0.0      X, D_min = C.X, C.D_min
    51        80      67371.0    842.1      0.0      V_max, g = C.V_max, C.g
    52        80      55227.0    690.3      0.0      S_h, S_h_0 = C.S_h, C.S_h[0]
    53        80      54168.0    677.1      0.0      p_height = 1 / len(S_h)
    54        80      76061.0    950.8      0.0      U_strong_prob = 1 / (2 * C.V_dev + 1)
    55        80     409146.0   5114.3      0.0      W_v = C.W_v
    56                                           
    57        80      33549.0    419.4      0.0      U = [
    58        80      68469.0    855.9      0.0          [0, C.U_no_flap, 1, [0]],
    59        80      54263.0    678.3      0.0          [1, C.U_weak, 1, [0]],
    60        80      42358.0    529.5      0.0          [2, C.U_strong, U_strong_prob, W_v]
    61                                               ]
    62                                           
    63        80     341212.0   4265.1      0.0      max_v = V_max + max(C.input_space) + max(W_v) - g
    64        80     162781.0   2034.8      0.0      min_v = -V_max + min(C.input_space) + min(W_v) - g
    65                                           
    66        80     986776.0  12334.7      0.0      Y_LOOKUP = {y_v: min(Y_limit, max(0, y_v)) for y_v in range(0-V_max, Y_limit+V_max+1)}
    67                                           
    68        80     637005.0   7962.6      0.0      V_LOOKUP = {(v+g): min(V_max, max(-V_max, v)) for v in range(min_v, max_v+1)}
    69                                           
    70    118880   54872288.0    461.6      2.1      for y_i, v_i, d_i, h_i, state_index, m_min in valid_states_with_indices:
    71    118800   41718299.0    351.2      1.6          y_j = Y_LOOKUP[y_i + v_i]
    72    118800   42429568.0    357.2      1.6          if d_i[0] == 0: # Passing
    73     36000   18202100.0    505.6      0.7              if abs(y_i - h_i[0]) > G_limit:
    74     31600    7799900.0    246.8      0.3                  continue # Crash!
    75      4400    2889483.0    656.7      0.1              dhat_j = (d_i[1] - 1, *d_i[2:], 0)
    76      4400    2140041.0    486.4      0.1              hhat_j = (*h_i[1:], S_h_0)
    77                                           
    78                                                       # We need to update m_min!
    79      4400    3106982.0    706.1      0.1              m_min = dhat_j[1:].index(0) + 1
    80                                                   else:
    81     82800   50090767.0    605.0      1.9              dhat_j = (d_i[0] - 1, *d_i[1:])
    82     82800   21721982.0    262.3      0.8              hhat_j = h_i
    83                                           
    84     87200   45143713.0    517.7      1.7          s = X - 1 - sum(dhat_j)
    85                                           
    86     87200   26648121.0    305.6      1.0          if s < D_min:
    87     68400   18602985.0    272.0      0.7              p_spawn = 0
    88     68400   19434431.0    284.1      0.7              p_no_spawn = 1
    89     18800    6890586.0    366.5      0.3          elif s >= X - 1:
    90      5040    1517412.0    301.1      0.1              p_spawn = 1
    91      5040    1535400.0    304.6      0.1              p_no_spawn = 0
    92                                                   else:
    93     13760    6939371.0    504.3      0.3              p_spawn = (s - (D_min - 1)) / (X - D_min)
    94     13760    5510762.0    400.5      0.2              p_no_spawn = 1 - p_spawn
    95                                           
    96     87200   29410318.0    337.3      1.1          if p_spawn > 0:
    97     18800   26591753.0   1414.5      1.0              spawn_array = state_to_index_array[y_j, :, *dhat_j[:m_min], s, *dhat_j[m_min+1:], *hhat_j[:m_min], :, *hhat_j[m_min+1:]]
    98                                           
    99     87200   28063301.0    321.8      1.1          if p_no_spawn > 0:
   100     82160   64505167.0    785.1      2.4              no_spawn_array = state_to_index_array[y_j, :, *dhat_j, *hhat_j]
   101                                           
   102                                                   # Each input will push to a seperate index in coo_*
   103                                                   # Important note: Duplicate entries will be SUMMED!
   104                                                   # This means that we do not have to worry about two inputs resulting in the same next_state (See += in compute_transition_probabilities)
   105     87200   32003669.0    367.0      1.2          p_b = p_spawn * p_height
   106    348800  128877950.0    369.5      4.9          for input_index, u_k, p_flap, W_v_list in U:
   107    261600   79969183.0    305.7      3.0              p_a = p_flap * p_no_spawn
   108    261600   71668432.0    274.0      2.7              p_b = p_flap * p_b
   109    697600  214464780.0    307.4      8.1              for w_v in W_v_list:
   110    436000  157202197.0    360.6      5.9                  v_j = V_LOOKUP[v_i + u_k + w_v]
   111                                           
   112                                                           # Case 1: No spawn
   113    436000  124786612.0    286.2      4.7                  if p_no_spawn > 0:
   114    410800  157953721.0    384.5      6.0                      j_index = no_spawn_array[v_j]
   115                                           
   116    410800  143231160.0    348.7      5.4                      append_data[input_index](p_a)
   117    410800  140457356.0    341.9      5.3                      append_rows[input_index](state_index)
   118    410800  138969966.0    338.3      5.2                      append_cols[input_index](j_index)
   119                                           
   120                                                           # Case 2: Spawn
   121    436000  128641398.0    295.0      4.9                  if p_spawn > 0:
   122    282000   79782442.0    282.9      3.0                      for height in S_h:
   123    188000   85769324.0    456.2      3.2                          j_index = spawn_array[v_j, height]
   124                                           
   125    188000   62087205.0    330.3      2.3                          append_data[input_index](p_b)
   126    188000   61707948.0    328.2      2.3                          append_rows[input_index](state_index)
   127    188000   64325002.0    342.2      2.4                          append_cols[input_index](j_index)
   128                                           
   129                                               # Construct the sparse matrices
   130        80      31077.0    388.5      0.0      P_sparse_list = []
   131       320    1219045.0   3809.5      0.0      for l in range(C.L):
   132                                                   # Build as COO first (fastest for this input)
   133       480  200938807.0 418622.5      7.6          P_l_coo = coo_matrix(
   134       240     213695.0    890.4      0.0              (coo_data[l], (coo_rows[l], coo_cols[l])),
   135       240      80670.0    336.1      0.0              shape=(K, K)
   136                                                   )
   137                                                   # Convert to CSC (fast, sums duplicates)
   138       240   46736283.0 194734.5      1.8          P_l = P_l_coo.tocsc()
   139       240     250633.0   1044.3      0.0          P_sparse_list.append(P_l)
   140                                           
   141        80      25163.0    314.5      0.0      return P_sparse_list

Total time: 3.84698 s
Average time: 0.0961745 s
File: /home/gblum/dev/dpc/Solver.py
Function: solution_linear_prog_sparse at line 107

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   107                                           def solution_linear_prog_sparse(C: Const) -> tuple[np.array, np.array]:
   108                                               """Computes the optimal cost and the optimal control policy.
   109                                           
   110                                               You can solve the SSP by any method:
   111                                               - Value Iteration
   112                                               - Policy Iteration
   113                                               - Linear Programming
   114                                               - A combination of the above
   115                                               - Others?
   116                                           
   117                                               Args:
   118                                                   C (Const): The constants describing the problem instance.
   119                                           
   120                                               Returns:
   121                                                   np.array: The optimal cost to go for the stochastic SPP,
   122                                                       of shape (C.K,), where C.K is the number of states.
   123                                                   np.array: The optimal control policy for the stochastic SPP,
   124                                                       of shape (C.K,), where each entry is in {0,...,C.L-1}.
   125                                               """
   126        40      93945.0   2348.6      0.0      ss = CustomStateSpace()
   127        40  600437954.0  1.5e+07     15.6      K, state_array, valid_states = ss.custom_state_space(C)
   128                                           
   129        40     369266.0   9231.6      0.0      J_opt = np.zeros(K)
   130        40      81096.0   2027.4      0.0      u_opt = np.zeros(K)
   131                                           
   132        40 2317226681.0 5.79e+07     60.2      P = compute_transition_probabilities(C, state_array, K, valid_states)
   133        40    2420059.0  60501.5      0.1      Q, b = compute_expected_stage_cost(C, K)
   134                                           
   135        40     406076.0  10151.9      0.0      c = np.full(K, -1, np.int64)
   136                                           
   137                                               # 1. Create a sparse identity matrix
   138        40    5574756.0 139368.9      0.1      I_sparse = eye(K, format='csc')
   139                                           
   140                                               # 2. Create a list to hold the sparse blocks (I - P_l)
   141        40      23087.0    577.2      0.0      A_blocks = []
   142                                           
   143                                               # 3. Loop over all actions
   144       160     212869.0   1330.4      0.0      for l in range(C.L):
   145                                                   # Add the sparse (I - P_l) block to our list
   146       120   31647147.0 263726.2      0.8          A_blocks.append(I_sparse - P[l])
   147                                           
   148                                               # 4. Stack all blocks vertically into one sparse matrix
   149        40   17976259.0 449406.5      0.5      A = vstack(A_blocks, format='csc')
   150                                           
   151                                               # 'highs' is the best for sparse problems
   152        40  860954909.0 2.15e+07     22.4      res = linprog(c, A_ub=A, b_ub=b, bounds=[None, 0], method='highs')
   153                                           
   154        40     262214.0   6555.4      0.0      J_opt = res.x
   155                                           
   156                                               # Create a list of weighted_J vectors, one for each action l
   157        40      16071.0    401.8      0.0      weighted_J_cols = []
   158       160     402689.0   2516.8      0.0      for l in range(C.L):
   159                                                   # P[l] is (K, K) sparse, J_opt is (K,) dense
   160                                                   # The @ operator performs efficient sparse-dot-dense
   161       120    4442820.0  37023.5      0.1          weighted_J_l = P[l] @ J_opt  # Result is a (K,) dense vector
   162       120      98560.0    821.3      0.0          weighted_J_cols.append(weighted_J_l)
   163                                           
   164                                               # Stack the (K,) vectors as columns into a (K, L) dense array
   165        40    1784097.0  44602.4      0.0      weighted_J_all = np.stack(weighted_J_cols, axis=1)
   166        40    1142954.0  28573.8      0.0      expected_values = Q + weighted_J_all
   167                                           
   168        40    1049752.0  26243.8      0.0      optimal_indices = np.argmin(expected_values, axis=1)
   169        40     339865.0   8496.6      0.0      u_opt = np.array(C.input_space)[optimal_indices]
   170                                           
   171        40      16837.0    420.9      0.0      return J_opt, u_opt

Total time: 22.0087 s
Average time: 22.0087 s
File: /home/gblum/dev/dpc/env/lib/python3.11/timeit.py
Function: Timer.timeit at line 166

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   166                                               def timeit(self, number=default_number):
   167                                                   """Time 'number' executions of the main statement.
   168                                           
   169                                                   To be precise, this executes the setup statement once, and
   170                                                   then returns the time it takes to execute the main statement
   171                                                   a number of times, as float seconds if using the default timer.   The
   172                                                   argument is the number of times through the loop, defaulting
   173                                                   to one million.  The main statement, the setup statement and
   174                                                   the timer function to be used are passed to the constructor.
   175                                                   """
   176         1       1930.0   1930.0      0.0          it = itertools.repeat(None, number)
   177         1        928.0    928.0      0.0          gcold = gc.isenabled()
   178         1        684.0    684.0      0.0          gc.disable()
   179         1        290.0    290.0      0.0          try:
   180         1      2.2e+10  2.2e+10    100.0              timing = self.inner(it, self.timer)
   181                                                   finally:
   182         1        512.0    512.0      0.0              if gcold:
   183         1    1109713.0 1.11e+06      0.0                  gc.enable()
   184         1       1077.0   1077.0      0.0          return timing

Total time: 0.650836 s
Average time: 1.08256e-05 s
File: /home/gblum/dev/dpc/utils.py
Function: CustomStateSpace.build_d_recursive at line 84

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    84                                               def build_d_recursive(self, y, v, current_d_list, current_d_sum, d_index, spot0):
    85                                                   """
    86                                                   Recursively builds the D-vector (d1, ..., dM) for a given
    87                                                   (y, v) prefix.
    88                                           
    89                                                   Pruning:
    90                                                   - sum(d) > X-1
    91                                                   - Trailing zeros (if d_i=0, all d_j for j>i must be 0)
    92                                                   - d2=0 if d1=0
    93                                                   """
    94                                                   # --- Base Case: D-vector is complete ---
    95     60120   21847314.0    363.4      3.4          if d_index == self.M:
    96                                                       # D-vector is built, now start building the H-vector
    97     38160   14498147.0    379.9      2.2              h_iterable = self.possible_h_iterables[spot0]
    98                                           
    99     38160   35939020.0    941.8      5.5              arr = self.state_to_index_array[y, v, *current_d_list, :]
   100     38160   16229228.0    425.3      2.5              final_d_list = tuple(current_d_list)
   101                                                       # 2. Loop over the product of these allowed H-options
   102    156960   48292235.0    307.7      7.4              for h_tuple in h_iterable:
   103    118800   67785625.0    570.6     10.4                  arr[*h_tuple] = self.current_index
   104    118800   66755851.0    561.9     10.3                  self.valid_states_with_indices.append((y, v, final_d_list, h_tuple, self.current_index, spot0))
   105    118800   48592457.0    409.0      7.5                  self.current_index += 1
   106                                           
   107     38160   10743162.0    281.5      1.7              return        # --- Recursive Step: Add d_i ---
   108     21960    6706090.0    305.4      1.0          if d_index == 0:
   109      2520    1045188.0    414.8      0.2              d_options = self.S_d1
   110     19440    6172338.0    317.5      0.9          elif spot0 > 0:
   111                                                       d_options = self.S_d0
   112                                                   else:
   113     19440    6760909.0    347.8      1.0              d_options = self.S_d
   114                                           
   115     82080   24727732.0    301.3      3.8          for d in d_options:
   116                                                       # 1. Sum constraint
   117     77040   31884340.0    413.9      4.9              if current_d_sum + d > self.X_limit:
   118     16920    5181322.0    306.2      0.8                  break # These are stored in increasing order
   119                                           
   120                                                       # 3. d1/d2 constraint (d1=0 -> d2>0)
   121                                                       # d_index == 1 is d2
   122     60120   19219822.0    319.7      3.0              if d_index == 1:
   123     40680   13118595.0    322.5      2.0                  d1 = current_d_list[0]
   124     40680   10717437.0    263.5      1.6                  d2 = d
   125     40680   13544340.0    332.9      2.1                  if d1 <= 0 and d2 == 0:
   126      2520     678932.0    269.4      0.1                      continue
   127                                           
   128     57600   16639660.0    288.9      2.6              next_spot0 = spot0
   129     57600   21126418.0    366.8      3.2              if spot0 == 0 and d_index > 0 and d == 0:
   130     16920    4445362.0    262.7      0.7                  next_spot0 = d_index  # This is the first zero
   131                                           
   132                                                       # Recurse with the added d
   133     57600   18588456.0    322.7      2.9              current_d_list[d_index] = d
   134    115200   40704493.0    353.3      6.3              self.build_d_recursive(
   135     57600   15286790.0    265.4      2.3                  y, v,
   136     57600   14831176.0    257.5      2.3                  current_d_list,
   137     57600   17080313.0    296.5      2.6                  current_d_sum + d,
   138     57600   17406762.0    302.2      2.7                  d_index + 1,
   139     57600   14286140.0    248.0      2.2                  next_spot0
   140                                                       )

Total time: 1.20358 s
Average time: 0.0150448 s
File: /home/gblum/dev/dpc/utils.py
Function: CustomStateSpace.custom_state_space at line 142

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   142                                               def custom_state_space(self, C: Const) -> Tuple[int, np.ndarray, list]:
   143                                                   """
   144                                                   Computes the state space and returns a state -> index dictionary
   145                                                   using a recursive, pruning-based generation method.
   146                                           
   147                                                   This function maintains the strict lexicographical ordering
   148                                                   from the problem statement, ensuring the state-to-index
   149                                                   mapping is identical to the original 'itertools.product' method,
   150                                                   but is significantly faster by pruning invalid branches early.
   151                                                   """
   152                                           
   153                                           
   154        80     109922.0   1374.0      0.0          self.current_index = 0
   155        80      58854.0    735.7      0.0          self.valid_states_with_indices = []
   156                                           
   157                                                   # --- Cache constants from C for minor speedup ---
   158        80     531186.0   6639.8      0.0          self.S_y, self.S_v = C.S_y, C.S_v
   159        80     401489.0   5018.6      0.0          self.S_d, self.S_d1 = C.S_d, C.S_d1
   160        80      99053.0   1238.2      0.0          self.S_h, self.S_h_default = C.S_h, C.S_h[0]
   161        80     333986.0   4174.8      0.0          self.M, self.X_limit = C.M, C.X - 1
   162                                           
   163                                                   # --- Create mappings for non-contiguous state variables ---
   164        80      41071.0    513.4      0.0          self.v_offset = C.V_max
   165                                           
   166                                                   # --- Initialize state_to_index_array ---
   167        80      87970.0   1099.6      0.0          dims = [C.Y, self.v_offset + 2 * C.V_max + 1]
   168       240     135572.0    564.9      0.0          for _ in range(self.M):
   169       160     100056.0    625.4      0.0              dims.append(C.X) # d values are 0..X-1
   170       240      90934.0    378.9      0.0          for _ in range(self.M):
   171       160      82842.0    517.8      0.0              dims.append(C.Y) # h values are 0..Y-1
   172                                           
   173        80   10889653.0 136120.7      0.9          self.state_to_index_array = np.full(dims, -1, dtype=np.int32)
   174                                           
   175                                           
   176                                                   # Pre-build the two possible lists for H-options
   177        80      62802.0    785.0      0.0          self.h_options_all = self.S_h
   178        80      60357.0    754.5      0.0          self.h_options_default = [self.S_h_default]
   179                                           
   180                                                   # Pre build an empty D-options list
   181        80      37544.0    469.3      0.0          self.S_d0 = [0]
   182                                           
   183        80     335151.0   4189.4      0.0          possible_h_iterables = [[self.h_options_all] + [self.h_options_all for i in range(1, self.M)]]
   184       160      91760.0    573.5      0.0          for spot0 in range(1, self.M):
   185       160     286046.0   1787.8      0.0              possible_h_iterables.append([self.h_options_all] + [
   186                                                           self.h_options_default if i >= spot0 else self.h_options_all
   187        80      37988.0    474.9      0.0                  for i in range(1, self.M)
   188                                                       ])
   189        80     406055.0   5075.7      0.0          self.possible_h_iterables = [list(product(*h_iter)) for h_iter in possible_h_iterables]
   190                                           
   191                                                   # The outer loops *must* be y, then v, to maintain order
   192       680     290314.0    426.9      0.0          for y in self.S_y:
   193      3120    1280594.0    410.4      0.1              for v in self.S_v:
   194      2520    1823579.0    723.6      0.2                  current_d_list_for_v = [0] * self.M
   195                                                           # Start the recursion for the D-vector
   196      2520 1185858040.0 470578.6     98.5                  self.build_d_recursive(y, v, current_d_list_for_v, 0, 0, 0)
   197                                           
   198        80      52030.0    650.4      0.0          return self.current_index, self.state_to_index_array, self.valid_states_with_indices


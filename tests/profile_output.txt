Timer unit: 1e-09 s

Total time: 0.0477268 s
File: /home/gblum/dev/dpc/ComputeExpectedStageCosts.py
Function: compute_expected_stage_cost_solver at line 23

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    23                                           def compute_expected_stage_cost_solver(C: Const, K: int) -> Tuple[np.array, np.array]:
    24      1152    3672879.0   3188.3      7.7      costs_row = np.array([
    25       576     416589.0    723.2      0.9          -1,                # Cost for action 0 (None)
    26       576    1182800.0   2053.5      2.5          C.lam_weak - 1,    # Cost for action 1 (Weak)
    27       576     383265.0    665.4      0.8          C.lam_strong - 1   # Cost for action 2 (Strong)
    28                                               ])
    29                                           
    30      1152   11507941.0   9989.5     24.1      b = np.concatenate((
    31       576   13498861.0  23435.5     28.3          np.repeat(costs_row[0], K),  # Column 0 of Q
    32       576    6242574.0  10837.8     13.1          np.repeat(costs_row[1], K),  # Column 1 of Q
    33       576    5589749.0   9704.4     11.7          np.repeat(costs_row[2], K)   # Column 2 of Q
    34                                               ))
    35                                           
    36       576    4977572.0   8641.6     10.4      Q = b.reshape((K, C.L), order='F')
    37                                           
    38       576     254590.0    442.0      0.5      return Q, b

Total time: 96.345 s
File: /home/gblum/dev/dpc/ComputeTransitionProbabilities.py
Function: compute_transition_probabilities_sparse at line 28

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    28                                           def compute_transition_probabilities_sparse(C:Const, state_to_index_dict, K) -> list:
    29                                               """Computes the transition probability matrix P as a list of sparse matrices."""
    30                                           
    31                                               # Each action in C.input_space will have its own sparse probability matrix
    32       576    4157434.0   7217.8      0.0      num_inputs = len(C.input_space)
    33                                           
    34                                               # A calculated probability P[curr_state, next_state, action] is stored as
    35                                               #   coo_data[action] = P[curr_state, next_state, action]
    36                                               #   coo_cols[action] = curr_state
    37                                               #   coo_rows[action] = next_state
    38       576    4507483.0   7825.5      0.0      coo_data = [[] for input_i in range(num_inputs)]
    39       576    1754236.0   3045.5      0.0      coo_cols = [[] for input_i in range(num_inputs)]
    40       576    2109818.0   3662.9      0.0      coo_rows = [[] for input_i in range(num_inputs)]
    41                                           
    42                                               # Helper functions for populating coo table
    43       576    2674541.0   4643.3      0.0      append_data = [l.append for l in coo_data]
    44       576    2066649.0   3587.9      0.0      append_rows = [l.append for l in coo_rows]
    45       576    1894697.0   3289.4      0.0      append_cols = [l.append for l in coo_cols]
    46                                           
    47                                               # Store variables once instead of recalculating
    48       576     801559.0   1391.6      0.0      Y_limit = C.Y - 1
    49       576    1188699.0   2063.7      0.0      G_limit = (C.G - 1) / 2
    50       576    2817441.0   4891.4      0.0      M = C.M
    51       576     426076.0    739.7      0.0      X, D_min = C.X, C.D_min
    52       576     580831.0   1008.4      0.0      V_max, g = C.V_max, C.g
    53       576     630830.0   1095.2      0.0      S_h, S_h_0 = C.S_h, C.S_h[0]
    54       576     492056.0    854.3      0.0      p_height = 1 / len(S_h)
    55       576     791342.0   1373.9      0.0      U_strong_prob = 1 / (2 * C.V_dev + 1)
    56       576    3630333.0   6302.7      0.0      W_v = C.W_v
    57                                           
    58       576     332489.0    577.2      0.0      StateVar_Y = 0
    59       576     255301.0    443.2      0.0      StateVar_V = 1
    60       576     305396.0    530.2      0.0      StateVar_D_1 = 2
    61       576     360834.0    626.4      0.0      StateVar_D_2 = StateVar_D_1 + 1
    62       576     427636.0    742.4      0.0      StateVar_D_M = StateVar_D_1 + M - 1
    63       576     359481.0    624.1      0.0      StateVar_H_1 = StateVar_D_M + 1
    64       576     317609.0    551.4      0.0      StateVar_H_2 = StateVar_H_1 + 1
    65       576     418497.0    726.6      0.0      StateVar_H_M = StateVar_H_1 + M - 1
    66                                           
    67       576     397918.0    690.8      0.0      U = [
    68       576     617755.0   1072.5      0.0          [0, C.U_no_flap, 1, [0]],
    69       576     543148.0    943.0      0.0          [1, C.U_weak, 1, [0]],
    70       576     570013.0    989.6      0.0          [2, C.U_strong, U_strong_prob, W_v]
    71                                               ]
    72                                           
    73                                               # Cache all possible Vs
    74       576    1764818.0   3063.9      0.0      v_space = C.S_v
    75       576     975410.0   1693.4      0.0      u_space = C.input_space
    76                                           
    77       576    2983135.0   5179.1      0.0      max_v = V_max + max(C.input_space) + max(W_v) - g
    78       576    1554638.0   2699.0      0.0      min_v = -V_max + min(C.input_space) + min(W_v) - g
    79                                           
    80       576     794806.0   1379.9      0.0      Y_LOOKUP_OFFSET = abs(0-V_max)
    81       576    7475866.0  12978.9      0.0      Y_LOOKUP = [min(Y_limit, max(0, y_v)) for y_v in range(0-V_max, Y_limit+V_max+1)]
    82                                           
    83       576     476536.0    827.3      0.0      V_LOOKUP_OFFSET = abs(min_v)
    84       576    5949573.0  10329.1      0.0      V_LOOKUP = [min(V_max, max(-V_max, v)) for v in range(min_v, max_v+1)]
    85                                           
    86   2709216 1203512634.0    444.2      1.2      for state_i, state_index in state_to_index_dict.items():
    87   2708640 1307651432.0    482.8      1.4          y_j = Y_LOOKUP[Y_LOOKUP_OFFSET + state_i[StateVar_Y] + state_i[StateVar_V]]
    88   2708640 1024695517.0    378.3      1.1          if state_i[StateVar_D_1] == 0: # Passing
    89   1144800  651690640.0    569.3      0.7              if abs(state_i[StateVar_Y] - state_i[StateVar_H_1]) > G_limit:
    90    959520  269850295.0    281.2      0.3                  continue # Crash!
    91    185280  150252933.0    811.0      0.2              dhat_j = (state_i[StateVar_D_2] - 1, *state_i[StateVar_D_2+1:StateVar_D_M+1], 0)
    92    185280  110497396.0    596.4      0.1              hhat_j = (*state_i[StateVar_H_2:StateVar_H_M + 1], S_h_0)
    93                                                   else:
    94   1563840 1158212453.0    740.6      1.2              dhat_j = (state_i[StateVar_D_1] - 1, *state_i[StateVar_D_2:StateVar_D_M + 1])
    95   1563840  824621090.0    527.3      0.9              hhat_j = (*state_i[StateVar_H_1:StateVar_H_M + 1], )
    96   1749120 1053453391.0    602.3      1.1          s = X - 1 - sum(dhat_j)
    97   1749120  829051064.0    474.0      0.9          p_spawn = (s - (D_min - 1)) / (X - D_min)
    98                                                   # TODO: Can p_spawn ever be 1 or greater?
    99   1749120  652128443.0    372.8      0.7          if p_spawn < 0:
   100    928320  294185555.0    316.9      0.3              p_spawn = 0
   101    820800  313769937.0    382.3      0.3          elif p_spawn > 1:
   102                                                       p_spawn = 1
   103                                                   # p_spawn = min(1, max(0, p_spawn))
   104   1749120  680087161.0    388.8      0.7          p_no_spawn = 1 - p_spawn
   105   1749120  502437744.0    287.3      0.5          try:
   106                                                       # m_min will be the Python index from the start of the list
   107   1749120 1312292497.0    750.3      1.4              m_min = dhat_j[1:].index(0) + 1
   108    406080  169233175.0    416.7      0.2          except ValueError:
   109                                                       # No zero was found in the slice, so m_min defaults to M-1
   110    406080  197557343.0    486.5      0.2              m_min = M - 1
   111   1749120  580368107.0    331.8      0.6          dspawn_j = None
   112   1749120  615626251.0    352.0      0.6          if p_spawn > 0:
   113    498240  447049994.0    897.3      0.5              dspawn_j = tuple(dhat_j[:m_min] + (s, ) + dhat_j[m_min+1:])
   114    498240  270522343.0    543.0      0.3              h_prefix = tuple(hhat_j[:m_min])
   115    498240  270327260.0    542.6      0.3              h_suffix = tuple(hhat_j[m_min+1:])
   116                                           
   117                                                   # Each input will push to a seperate index in coo_*
   118                                                   # Important note: Duplicate entries will be SUMMED!
   119                                                   # This means that we do not have to worry about two inputs resulting in the same next_state (See += in compute_transition_probabilities)
   120   6996480 2911305198.0    416.1      3.0          for input_index, u_k, p_flap, W_v_list in U:
   121  17491200 5747699525.0    328.6      6.0              for w_v in W_v_list:
   122  12243840 5874157943.0    479.8      6.1                  v_j = V_LOOKUP[V_LOOKUP_OFFSET + state_i[StateVar_V] + u_k + w_v - g]
   123                                           
   124                                                           # Case 1: No spawn
   125  12243840 3972495613.0    324.4      4.1                  if p_no_spawn > 0:
   126                                                               # Big speed up options:
   127                                                               # TODO: j_index can be auto calculated using an understanding of the state
   128                                                               # TODO: Use a function that CALCULATES a state -> index mapping using knowledge of state construction
   129  11820480 5693114936.0    481.6      5.9                      next_state = (y_j, v_j) + dhat_j + hhat_j
   130  11820480 5608705104.0    474.5      5.8                      j_index = state_to_index_dict[next_state]
   131                                           
   132  11820480 5533926596.0    468.2      5.7                      append_data[input_index](p_flap * p_no_spawn)
   133  11820480 4615188394.0    390.4      4.8                      append_rows[input_index](state_index)
   134  11820480 4461491866.0    377.4      4.6                      append_cols[input_index](j_index)
   135                                           
   136                                                           # Case 2: Spawn
   137  12243840 4448122806.0    363.3      4.6                  if p_spawn > 0:
   138   3487680 1475901004.0    423.2      1.5                      spawn_prefix = (y_j, v_j) + dspawn_j
   139   3487680 1356191334.0    388.9      1.4                      p_combined = p_flap * p_spawn * p_height
   140  12126240 3801145161.0    313.5      3.9                      for height in S_h:
   141                                                                   # Big speed up options:
   142                                                                   # TODO: j_index can be auto calculated using an understanding of the state
   143                                                                   # TODO: Use a function that CALCULATES a state -> index mapping using knowledge of state construction
   144   8638560 4384272821.0    507.5      4.6                          next_state = spawn_prefix + h_prefix + (height,) + h_suffix
   145   8638560 4107968037.0    475.5      4.3                          j_index = state_to_index_dict[next_state]
   146                                           
   147   8638560 3375163814.0    390.7      3.5                          append_data[input_index](p_combined)
   148   8638560 3260147865.0    377.4      3.4                          append_rows[input_index](state_index)
   149   8638560 3412607609.0    395.0      3.5                          append_cols[input_index](j_index)
   150                                           
   151                                               # Construct the sparse matrices
   152       576     463770.0    805.2      0.0      P_sparse_list = []
   153      2304    8715432.0   3782.7      0.0      for l in range(C.L):
   154                                                   # Build as COO first (fastest for this input)
   155      3456 6799365442.0 1.97e+06      7.1          P_l_coo = coo_matrix(
   156      1728    1981518.0   1146.7      0.0              (coo_data[l], (coo_rows[l], coo_cols[l])),
   157      1728     600613.0    347.6      0.0              shape=(K, K)
   158                                                   )
   159                                                   # Convert to CSC (fast, sums duplicates)
   160      1728  545108011.0 315456.0      0.6          P_l = P_l_coo.tocsc()
   161      1728    2436638.0   1410.1      0.0          P_sparse_list.append(P_l)
   162                                           
   163       576     204132.0    354.4      0.0      return P_sparse_list

Total time: 339.798 s
File: /home/gblum/dev/dpc/Solver.py
Function: solution_linear_prog_sparse at line 107

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   107                                           def solution_linear_prog_sparse(C: Const) -> tuple[np.array, np.array]:
   108                                               """Computes the optimal cost and the optimal control policy.
   109                                           
   110                                               You can solve the SSP by any method:
   111                                               - Value Iteration
   112                                               - Policy Iteration
   113                                               - Linear Programming
   114                                               - A combination of the above
   115                                               - Others?
   116                                           
   117                                               Args:
   118                                                   C (Const): The constants describing the problem instance.
   119                                           
   120                                               Returns:
   121                                                   np.array: The optimal cost to go for the stochastic SPP,
   122                                                       of shape (C.K,), where C.K is the number of states.
   123                                                   np.array: The optimal control policy for the stochastic SPP,
   124                                                       of shape (C.K,), where each entry is in {0,...,C.L-1}.
   125                                               """
   126       576    1026549.0   1782.2      0.0      ss = CustomStateSpace()
   127       576     2.58e+10 4.48e+07      7.6      K, state_dict = ss.custom_state_space(C)
   128                                           
   129       576    8611681.0  14950.8      0.0      J_opt = np.zeros(K)
   130       576    2368642.0   4112.2      0.0      u_opt = np.zeros(K)
   131                                           
   132       576     1.62e+11 2.82e+08     47.8      P = compute_transition_probabilities(C, state_dict, K)
   133       576   53352554.0  92626.0      0.0      Q, b = compute_expected_stage_cost(C, K)
   134                                           
   135       576    8356357.0  14507.6      0.0      c = np.full(K, -1, np.int64)
   136                                           
   137                                               # 1. Create a sparse identity matrix
   138       576  107200059.0 186111.2      0.0      I_sparse = eye(K, format='csc')
   139                                           
   140                                               # 2. Create a list to hold the sparse blocks (I - P_l)
   141       576     511686.0    888.3      0.0      A_blocks = []
   142                                           
   143                                               # 3. Loop over all actions
   144      2304    4223488.0   1833.1      0.0      for l in range(C.L):
   145                                                   # Add the sparse (I - P_l) block to our list
   146      1728  632083261.0 365788.9      0.2          A_blocks.append(I_sparse - P[l])
   147                                           
   148                                               # 4. Stack all blocks vertically into one sparse matrix
   149       576  412560662.0 716251.1      0.1      A = vstack(A_blocks, format='csc')
   150                                           
   151                                               # 'highs' is the best for sparse problems
   152       576      1.5e+11 2.61e+08     44.2      res = linprog(c, A_ub=A, b_ub=b, bounds=[None, 0], method='highs')
   153                                           
   154       576    4081240.0   7085.5      0.0      J_opt = res.x
   155                                           
   156                                               # Create a list of weighted_J vectors, one for each action l
   157       576     359395.0    623.9      0.0      weighted_J_cols = []
   158      2148    5711572.0   2659.0      0.0      for l in range(C.L):
   159                                                   # P[l] is (K, K) sparse, J_opt is (K,) dense
   160                                                   # The @ operator performs efficient sparse-dot-dense
   161      1624   87350897.0  53787.5      0.0          weighted_J_l = P[l] @ J_opt  # Result is a (K,) dense vector
   162      1572    1525601.0    970.5      0.0          weighted_J_cols.append(weighted_J_l)
   163                                           
   164                                               # Stack the (K,) vectors as columns into a (K, L) dense array
   165       524   31142025.0  59431.3      0.0      weighted_J_all = np.stack(weighted_J_cols, axis=1)
   166       524   28420705.0  54238.0      0.0      expected_values = Q + weighted_J_all
   167                                           
   168       524   33354294.0  63653.2      0.0      optimal_indices = np.argmin(expected_values, axis=1)
   169       524    8353869.0  15942.5      0.0      u_opt = np.array(C.input_space)[optimal_indices]
   170                                           
   171       524     236270.0    450.9      0.0      return J_opt, u_opt

Total time: 0 s
File: /home/gblum/dev/dpc/Solver.py
Function: solution_value_iteration at line 173

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   173                                           def solution_value_iteration(C: Const, epsilon=1e-8, max_iter=10000) -> tuple[np.array, np.array]:
   174                                               """Computes the optimal cost and the optimal control policy.
   175                                           
   176                                               You can solve the SSP by any method:
   177                                               - Value Iteration
   178                                               - Policy Iteration
   179                                               - Linear Programming
   180                                               - A combination of the above
   181                                               - Others?
   182                                           
   183                                               Args:
   184                                                   C (Const): The constants describing the problem instance.
   185                                           
   186                                               Returns:
   187                                                   np.array: The optimal cost to go for the stochastic SPP,
   188                                                       of shape (C.K,), where C.K is the number of states.
   189                                                   np.array: The optimal control policy for the stochastic SPP,
   190                                                       of shape (C.K,), where each entry is in {0,...,C.L-1}.
   191                                               """
   192                                           
   193                                               ss = CustomStateSpace()
   194                                               K, state_dict = ss.custom_state_space(C)
   195                                               P = compute_transition_probabilities(C, state_dict, K)
   196                                               Q, _ = compute_expected_stage_cost(C, K)
   197                                           
   198                                               # 2. Initialize J (Value function)
   199                                               J = np.zeros(K)
   200                                           
   201                                               # Pre-allocate arrays
   202                                               J_current = np.zeros(K)
   203                                               J_next = np.empty(K)
   204                                           
   205                                               val_l = np.empty(K)
   206                                           
   207                                               for i in range(max_iter):
   208                                                   # 1. Initialize J_next with the value of the first action (l=0)
   209                                                   # Q[:, 0] is (K,), P[0] @ J_old is (K,)
   210                                                   np.add(Q[:, 0], (P[0] @ J_current), out=J_next)
   211                                           
   212                                                   # 2. Loop from the second action (l=1)
   213                                                   for l in range(1, C.L):
   214                                                       # Calculate the value for this action: Q_l + P_l * J_current
   215                                                       np.add(Q[:, l], (P[l] @ J_current), out=val_l)
   216                                           
   217                                                       # Update J_next to be the element-wise minimum
   218                                                       np.minimum(J_next, val_l, out=J_next)
   219                                           
   220                                                   if np.max(np.abs(J_next - J_current)) < epsilon:
   221                                                       J_current = J_next  # Converged. J_next is the final value.
   222                                                       break
   223                                           
   224                                                   J_current, J_next = J_next, J_current
   225                                           
   226                                               # 4. Recover the optimal policy (u_opt)
   227                                               expected_values_cols = []
   228                                               for l in range(C.L):
   229                                                   # Use the final converged J_opt
   230                                                   val_l = Q[:, l] + (P[l] @ J_current)
   231                                                   expected_values_cols.append(val_l)
   232                                           
   233                                               expected_values = np.stack(expected_values_cols, axis=1)
   234                                           
   235                                               optimal_indices = np.argmin(expected_values, axis=1)
   236                                               u_opt = np.array(C.input_space)[optimal_indices]
   237                                           
   238                                               return J_current, u_opt

Total time: 339.925 s
File: /home/gblum/dev/dpc/Solver.py
Function: solution_picker at line 248

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   248                                           def solution_picker(C: Const) -> tuple[np.array, np.array]:
   249                                               # TODO: Minor, but this is technically overhead
   250                                           
   251       576     976762.0   1695.8      0.0      selected_solution = SOLUTION_FUNCTIONS[SOL_LP]
   252                                           
   253       576      3.4e+11  5.9e+08    100.0      return selected_solution(C)

Total time: 13.4497 s
File: /home/gblum/dev/dpc/utils.py
Function: CustomStateSpace.build_d_recursive at line 83

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    83                                               def build_d_recursive(self, y, v, current_d_list, current_d_sum, d_index, spot0):
    84                                                   """
    85                                                   Recursively builds the D-vector (d1, ..., dM) for a given
    86                                                   (y, v) prefix.
    87                                           
    88                                                   Pruning:
    89                                                   - sum(d) > X-1
    90                                                   - Trailing zeros (if d_i=0, all d_j for j>i must be 0)
    91                                                   - d2=0 if d1=0
    92                                                   """
    93                                                   # --- Base Case: D-vector is complete ---
    94   1023840  407072259.0    397.6      3.0          if d_index == self.M:
    95                                                       # D-vector is built, now start building the H-vector
    96    505440  210514783.0    416.5      1.6              h_iterable = self.possible_h_iterables[spot0]
    97                                           
    98    505440  313702195.0    620.7      2.3              prefix = (y, v) + tuple(current_d_list)
    99                                           
   100                                                       # 2. Loop over the product of these allowed H-options
   101   3214080 1041253829.0    324.0      7.7              for h_tuple in h_iterable:
   102   2708640 1209263450.0    446.4      9.0                  state = prefix + h_tuple
   103   2708640 1464208521.0    540.6     10.9                  self.state_to_index_dict[state] = self.current_index
   104   2708640 1139845923.0    420.8      8.5                  self.current_index += 1
   105                                           
   106    505440  157482114.0    311.6      1.2              return
   107                                           
   108                                                   # --- Recursive Step: Add d_i ---
   109    518400  183364999.0    353.7      1.4          if d_index == 0:
   110     25920   11330304.0    437.1      0.1              d_options = self.S_d1
   111    492480  173550819.0    352.4      1.3          elif spot0 > 0:
   112     90720   33460116.0    368.8      0.2              d_options = self.S_d0
   113                                                   else:
   114    401760  139404893.0    347.0      1.0              d_options = self.S_d
   115                                           
   116   3019680 1027674888.0    340.3      7.6          for d in d_options:
   117                                                       # 1. Sum constraint
   118   2501280 1028658008.0    411.3      7.6              if current_d_sum + d > self.X_limit:
   119   1477440  422117837.0    285.7      3.1                  continue
   120                                           
   121                                                       # 3. d1/d2 constraint (d1=0 -> d2>0)
   122                                                       # d_index == 1 is d2
   123   1023840  369176930.0    360.6      2.7              if d_index == 1:
   124    479520  180502797.0    376.4      1.3                  d1 = current_d_list[0]
   125    479520  148437819.0    309.6      1.1                  d2 = d
   126    479520  177262432.0    369.7      1.3                  if d1 <= 0 and d2 == 0:
   127     25920    7746259.0    298.9      0.1                      continue
   128                                           
   129    997920  339270543.0    340.0      2.5              next_spot0 = spot0
   130    997920  434828399.0    435.7      3.2              if spot0 == 0 and d_index > 0 and d == 0:
   131    375840  110839784.0    294.9      0.8                  next_spot0 = d_index  # This is the first zero
   132                                           
   133                                                       # Recurse with the added d
   134    997920  381957575.0    382.8      2.8              current_d_list[d_index] = d
   135   1995840  786539812.0    394.1      5.8              self.build_d_recursive(
   136    997920  307461164.0    308.1      2.3                  y, v,
   137    997920  290528597.0    291.1      2.2                  current_d_list,
   138    997920  321947399.0    322.6      2.4                  current_d_sum + d,
   139    997920  345565666.0    346.3      2.6                  d_index + 1,
   140                                                           # Update zero_seen flag:
   141                                                           # (zero_seen is True if it was already True, OR
   142                                                           # if we are adding a zero *after* d1)
   143    997920  284720676.0    285.3      2.1                  next_spot0
   144                                                       )

Total time: 25.7739 s
File: /home/gblum/dev/dpc/utils.py
Function: CustomStateSpace.custom_state_space at line 146

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   146                                               def custom_state_space(self, C: Const) -> Tuple[int, Dict[Tuple[int, ...], int]]:
   147                                                   """
   148                                                   Computes the state space and returns a state -> index dictionary
   149                                                   using a recursive, pruning-based generation method.
   150                                           
   151                                                   This function maintains the strict lexicographical ordering
   152                                                   from the problem statement, ensuring the state-to-index
   153                                                   mapping is identical to the original 'itertools.product' method,
   154                                                   but is significantly faster by pruning invalid branches early.
   155                                                   """
   156                                           
   157                                           
   158       576     578292.0   1004.0      0.0          self.state_to_index_dict = {}
   159       576     429209.0    745.2      0.0          self.current_index = 0
   160                                           
   161                                                   # --- Cache constants from C for minor speedup ---
   162       576    4923050.0   8547.0      0.0          self.S_y, self.S_v = C.S_y, C.S_v
   163       576    3241157.0   5627.0      0.0          self.S_d, self.S_d1 = C.S_d, C.S_d1
   164       576     765089.0   1328.3      0.0          self.S_h, self.S_h_default = C.S_h, C.S_h[0]
   165       576    2294563.0   3983.6      0.0          self.M, self.X_limit = C.M, C.X - 1
   166                                           
   167                                                   # Pre-build the two possible lists for H-options
   168       576     450339.0    781.8      0.0          self.h_options_all = self.S_h
   169       576     432751.0    751.3      0.0          self.h_options_default = [self.S_h_default]
   170                                           
   171                                                   # Pre build an empty D-options list
   172       576     361506.0    627.6      0.0          self.S_d0 = [0]
   173                                           
   174       576    2570163.0   4462.1      0.0          possible_h_iterables = [[self.h_options_all] + [self.h_options_all for i in range(1, self.M)]]
   175      1440     987027.0    685.4      0.0          for spot0 in range(1, self.M):
   176      1728    4310817.0   2494.7      0.0              possible_h_iterables.append([self.h_options_all] + [
   177                                                           self.h_options_default if i >= spot0 else self.h_options_all
   178       864     459304.0    531.6      0.0                  for i in range(1, self.M)
   179                                                       ])
   180       576    4191656.0   7277.2      0.0          self.possible_h_iterables = [list(product(*h_iter)) for h_iter in possible_h_iterables]
   181                                           
   182                                                   # The outer loops *must* be y, then v, to maintain order
   183      5760    3558001.0    617.7      0.0          for y in self.S_y:
   184     31104   17269470.0    555.2      0.1              for v in self.S_v:
   185     25920   28536103.0   1100.9      0.1                  current_d_list_for_v = [0] * self.M
   186                                                           # Start the recursion for the D-vector
   187     25920     2.57e+10 991387.2     99.7                  self.build_d_recursive(y, v, current_d_list_for_v, 0, 0, 0)
   188                                           
   189       576    1772117.0   3076.6      0.0          return len(self.state_to_index_dict), self.state_to_index_dict


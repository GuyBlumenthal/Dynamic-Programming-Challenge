Timer unit: 1e-09 s

Total time: 0.00235643 s
Average time: 2.94554e-05 s
File: /home/gblum/dev/dpc/ComputeExpectedStageCosts.py
Function: compute_expected_stage_cost_solver at line 23

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    23                                           def compute_expected_stage_cost_solver(C: Const, K: int) -> Tuple[np.array, np.array]:
    24        80     181857.0   2273.2      7.7      costs_row = np.array([
    25        40      19909.0    497.7      0.8          -1,                # Cost for action 0 (None)
    26        40      48277.0   1206.9      2.0          C.lam_weak - 1,    # Cost for action 1 (Weak)
    27        40      21293.0    532.3      0.9          C.lam_strong - 1   # Cost for action 2 (Strong)
    28                                               ])
    29                                           
    30        80     448076.0   5600.9     19.0      b = np.concatenate((
    31        40     791372.0  19784.3     33.6          np.repeat(costs_row[0], K),  # Column 0 of Q
    32        40     292789.0   7319.7     12.4          np.repeat(costs_row[1], K),  # Column 1 of Q
    33        40     252422.0   6310.6     10.7          np.repeat(costs_row[2], K)   # Column 2 of Q
    34                                               ))
    35                                           
    36        40     283224.0   7080.6     12.0      Q = b.reshape((K, C.L), order='F')
    37                                           
    38        40      17213.0    430.3      0.7      return Q, b

Total time: 2.86949 s
Average time: 0.0358686 s
File: /home/gblum/dev/dpc/ComputeTransitionProbabilities.py
Function: compute_transition_probabilities_sparse at line 28

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    28                                           def compute_transition_probabilities_sparse(C:Const, state_to_index_array, K, valid_states_with_indices) -> list:
    29                                               """Computes the transition probability matrix P as a list of sparse matrices."""
    30                                           
    31                                               # Each action in C.input_space will have its own sparse probability matrix
    32        80     553574.0   6919.7      0.0      num_inputs = len(C.input_space)
    33                                           
    34                                               # A calculated probability P[curr_state, next_state, action] is stored as
    35                                               #   coo_data[action] = P[curr_state, next_state, action]
    36                                               #   coo_cols[action] = curr_state
    37                                               #   coo_rows[action] = next_state
    38        80     556126.0   6951.6      0.0      coo_data = [[] for input_i in range(num_inputs)]
    39        80     206765.0   2584.6      0.0      coo_cols = [[] for input_i in range(num_inputs)]
    40        80     313600.0   3920.0      0.0      coo_rows = [[] for input_i in range(num_inputs)]
    41                                           
    42                                               # Helper functions for populating coo table
    43        80     264333.0   3304.2      0.0      append_data = [l.append for l in coo_data]
    44        80     210696.0   2633.7      0.0      append_rows = [l.append for l in coo_rows]
    45        80     210816.0   2635.2      0.0      append_cols = [l.append for l in coo_cols]
    46                                           
    47                                               # Store variables once instead of recalculating
    48        80      88516.0   1106.5      0.0      Y_limit = C.Y - 1
    49        80     150432.0   1880.4      0.0      G_limit = (C.G - 1) / 2
    50        80      73071.0    913.4      0.0      X, D_min = C.X, C.D_min
    51        80      77721.0    971.5      0.0      V_max, g = C.V_max, C.g
    52        80      78368.0    979.6      0.0      S_h, S_h_0 = C.S_h, C.S_h[0]
    53        80      67125.0    839.1      0.0      p_height = 1 / len(S_h)
    54        80      82018.0   1025.2      0.0      U_strong_prob = 1 / (2 * C.V_dev + 1)
    55        80     447760.0   5597.0      0.0      W_v = C.W_v
    56                                           
    57        80      41097.0    513.7      0.0      U = [
    58        80      60545.0    756.8      0.0          [0, C.U_no_flap, 1, [0]],
    59        80      60388.0    754.9      0.0          [1, C.U_weak, 1, [0]],
    60        80      44415.0    555.2      0.0          [2, C.U_strong, U_strong_prob, W_v]
    61                                               ]
    62                                           
    63        80     402899.0   5036.2      0.0      max_v = V_max + max(C.input_space) + max(W_v) - g
    64        80     173209.0   2165.1      0.0      min_v = -V_max + min(C.input_space) + min(W_v) - g
    65                                           
    66        80    1062628.0  13282.9      0.0      Y_LOOKUP = {y_v: min(Y_limit, max(0, y_v)) for y_v in range(0-V_max, Y_limit+V_max+1)}
    67                                           
    68       240    2764467.0  11518.6      0.1      V_LOOKUP = np.full((
    69        80      49581.0    619.8      0.0          C.V_max * 2 + 1,
    70        80     127963.0   1599.5      0.0          max(C.input_space) + 1,
    71        80      30202.0    377.5      0.0          C.V_dev * 2 + 1
    72        80      21222.0    265.3      0.0      ), -1)
    73                                           
    74       400     215276.0    538.2      0.0      for v in range(-V_max, V_max + 1):
    75      1280     677152.0    529.0      0.0          for u in C.input_space:
    76      3840    1156105.0    301.1      0.0              for w_v in W_v:
    77      2880    3617791.0   1256.2      0.1                  V_LOOKUP[v][u][w_v] = min(V_max, max(-V_max, v + u + w_v - g))
    78                                           
    79    118880   57779376.0    486.0      2.0      for y_i, v_i, d_i, h_i, state_index, m_min in valid_states_with_indices:
    80    118800   43811406.0    368.8      1.5          y_j = Y_LOOKUP[y_i + v_i]
    81    118800   46381336.0    390.4      1.6          if d_i[0] == 0: # Passing
    82     36000   18887502.0    524.7      0.7              if abs(y_i - h_i[0]) > G_limit:
    83     31600    7916348.0    250.5      0.3                  continue # Crash!
    84      4400    3373912.0    766.8      0.1              dhat_j = (d_i[1] - 1, *d_i[2:], 0)
    85      4400    2392377.0    543.7      0.1              hhat_j = (*h_i[1:], S_h_0)
    86                                           
    87                                                       # We need to update m_min!
    88      4400    3417417.0    776.7      0.1              m_min = dhat_j[1:].index(0) + 1
    89                                                   else:
    90     82800   55931459.0    675.5      1.9              dhat_j = (d_i[0] - 1, *d_i[1:])
    91     82800   21158324.0    255.5      0.7              hhat_j = h_i
    92                                           
    93     87200   46459202.0    532.8      1.6          s = X - 1 - sum(dhat_j)
    94                                           
    95     87200   28946214.0    332.0      1.0          if s < D_min:
    96     68400   20080865.0    293.6      0.7              p_spawn = 0
    97     68400   21487018.0    314.1      0.7              p_no_spawn = 1
    98     18800    7248229.0    385.5      0.3          elif s >= X - 1:
    99      5040    1831622.0    363.4      0.1              p_spawn = 1
   100      5040    1654618.0    328.3      0.1              p_no_spawn = 0
   101                                                   else:
   102     13760    7348719.0    534.1      0.3              p_spawn = (s - (D_min - 1)) / (X - D_min)
   103     13760    6148822.0    446.9      0.2              p_no_spawn = 1 - p_spawn
   104                                           
   105     87200   31709981.0    363.6      1.1          if p_spawn > 0:
   106     18800   30099202.0   1601.0      1.0              spawn_array = state_to_index_array[y_j, :, *dhat_j[:m_min], s, *dhat_j[m_min+1:], *hhat_j[:m_min], :, *hhat_j[m_min+1:]]
   107                                           
   108     87200   26358574.0    302.3      0.9          if p_no_spawn > 0:
   109     82160   69145799.0    841.6      2.4              no_spawn_array = state_to_index_array[y_j, :, *dhat_j, *hhat_j]
   110                                           
   111                                                   # Each input will push to a seperate index in coo_*
   112                                                   # Important note: Duplicate entries will be SUMMED!
   113                                                   # This means that we do not have to worry about two inputs resulting in the same next_state (See += in compute_transition_probabilities)
   114     87200   31047215.0    356.0      1.1          p_b = p_spawn * p_height
   115    348800  129757208.0    372.0      4.5          for input_index, u_k, p_flap, W_v_list in U:
   116    261600   83328505.0    318.5      2.9              p_a = p_flap * p_no_spawn
   117    261600   79197137.0    302.7      2.8              p_b = p_flap * p_b
   118    697600  220005571.0    315.4      7.7              for w_v in W_v_list:
   119    436000  221154484.0    507.2      7.7                  v_j = V_LOOKUP[v_i, u_k, w_v]
   120                                           
   121                                                           # Case 1: No spawn
   122    436000  127888602.0    293.3      4.5                  if p_no_spawn > 0:
   123    410800  177844094.0    432.9      6.2                      j_index = no_spawn_array[v_j]
   124                                           
   125    410800  152649532.0    371.6      5.3                      append_data[input_index](p_a)
   126    410800  145310157.0    353.7      5.1                      append_rows[input_index](state_index)
   127    410800  145807216.0    354.9      5.1                      append_cols[input_index](j_index)
   128                                           
   129                                                           # Case 2: Spawn
   130    436000  139925277.0    320.9      4.9                  if p_spawn > 0:
   131    282000   85567425.0    303.4      3.0                      for height in S_h:
   132    188000   93477584.0    497.2      3.3                          j_index = spawn_array[v_j, height]
   133                                           
   134    188000   66025246.0    351.2      2.3                          append_data[input_index](p_b)
   135    188000   65887383.0    350.5      2.3                          append_rows[input_index](state_index)
   136    188000   68197407.0    362.8      2.4                          append_cols[input_index](j_index)
   137                                           
   138                                               # Construct the sparse matrices
   139        80      36797.0    460.0      0.0      P_sparse_list = []
   140       320    1263401.0   3948.1      0.0      for l in range(C.L):
   141                                                   # Build as COO first (fastest for this input)
   142       480  211638773.0 440914.1      7.4          P_l_coo = coo_matrix(
   143       240     192537.0    802.2      0.0              (coo_data[l], (coo_rows[l], coo_cols[l])),
   144       240      77038.0    321.0      0.0              shape=(K, K)
   145                                                   )
   146                                                   # Convert to CSC (fast, sums duplicates)
   147       240   49462518.0 206093.8      1.7          P_l = P_l_coo.tocsc()
   148       240     265213.0   1105.1      0.0          P_sparse_list.append(P_l)
   149                                           
   150        80      25943.0    324.3      0.0      return P_sparse_list

Total time: 3.99491 s
Average time: 0.0998727 s
File: /home/gblum/dev/dpc/Solver.py
Function: solution_linear_prog_sparse at line 107

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   107                                           def solution_linear_prog_sparse(C: Const) -> tuple[np.array, np.array]:
   108                                               """Computes the optimal cost and the optimal control policy.
   109                                           
   110                                               You can solve the SSP by any method:
   111                                               - Value Iteration
   112                                               - Policy Iteration
   113                                               - Linear Programming
   114                                               - A combination of the above
   115                                               - Others?
   116                                           
   117                                               Args:
   118                                                   C (Const): The constants describing the problem instance.
   119                                           
   120                                               Returns:
   121                                                   np.array: The optimal cost to go for the stochastic SPP,
   122                                                       of shape (C.K,), where C.K is the number of states.
   123                                                   np.array: The optimal control policy for the stochastic SPP,
   124                                                       of shape (C.K,), where each entry is in {0,...,C.L-1}.
   125                                               """
   126        40     105400.0   2635.0      0.0      ss = CustomStateSpace()
   127        40  564734444.0 1.41e+07     14.1      K, state_array, valid_states = ss.custom_state_space(C)
   128                                           
   129        40     445261.0  11131.5      0.0      J_opt = np.zeros(K)
   130        40     107917.0   2697.9      0.0      u_opt = np.zeros(K)
   131                                           
   132        40 2445452859.0 6.11e+07     61.2      P = compute_transition_probabilities(C, state_array, K, valid_states)
   133        40    2722514.0  68062.9      0.1      Q, b = compute_expected_stage_cost(C, K)
   134                                           
   135        40     457243.0  11431.1      0.0      c = np.full(K, -1, np.int64)
   136                                           
   137                                               # 1. Create a sparse identity matrix
   138        40    5852085.0 146302.1      0.1      I_sparse = eye(K, format='csc')
   139                                           
   140                                               # 2. Create a list to hold the sparse blocks (I - P_l)
   141        40      21115.0    527.9      0.0      A_blocks = []
   142                                           
   143                                               # 3. Loop over all actions
   144       160     223838.0   1399.0      0.0      for l in range(C.L):
   145                                                   # Add the sparse (I - P_l) block to our list
   146       120   32740081.0 272834.0      0.8          A_blocks.append(I_sparse - P[l])
   147                                           
   148                                               # 4. Stack all blocks vertically into one sparse matrix
   149        40   18588956.0 464723.9      0.5      A = vstack(A_blocks, format='csc')
   150                                           
   151                                               # 'highs' is the best for sparse problems
   152        40  913991422.0 2.28e+07     22.9      res = linprog(c, A_ub=A, b_ub=b, bounds=[None, 0], method='highs')
   153                                           
   154        40     272738.0   6818.4      0.0      J_opt = res.x
   155                                           
   156                                               # Create a list of weighted_J vectors, one for each action l
   157        40      21898.0    547.5      0.0      weighted_J_cols = []
   158       160     366168.0   2288.6      0.0      for l in range(C.L):
   159                                                   # P[l] is (K, K) sparse, J_opt is (K,) dense
   160                                                   # The @ operator performs efficient sparse-dot-dense
   161       120    4480444.0  37337.0      0.1          weighted_J_l = P[l] @ J_opt  # Result is a (K,) dense vector
   162       120      97131.0    809.4      0.0          weighted_J_cols.append(weighted_J_l)
   163                                           
   164                                               # Stack the (K,) vectors as columns into a (K, L) dense array
   165        40    1769174.0  44229.3      0.0      weighted_J_all = np.stack(weighted_J_cols, axis=1)
   166        40     991072.0  24776.8      0.0      expected_values = Q + weighted_J_all
   167                                           
   168        40    1078099.0  26952.5      0.0      optimal_indices = np.argmin(expected_values, axis=1)
   169        40     370663.0   9266.6      0.0      u_opt = np.array(C.input_space)[optimal_indices]
   170                                           
   171        40      18089.0    452.2      0.0      return J_opt, u_opt

Total time: 23.0321 s
Average time: 23.0321 s
File: /home/gblum/dev/dpc/env/lib/python3.11/timeit.py
Function: Timer.timeit at line 166

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   166                                               def timeit(self, number=default_number):
   167                                                   """Time 'number' executions of the main statement.
   168                                           
   169                                                   To be precise, this executes the setup statement once, and
   170                                                   then returns the time it takes to execute the main statement
   171                                                   a number of times, as float seconds if using the default timer.   The
   172                                                   argument is the number of times through the loop, defaulting
   173                                                   to one million.  The main statement, the setup statement and
   174                                                   the timer function to be used are passed to the constructor.
   175                                                   """
   176         1       2501.0   2501.0      0.0          it = itertools.repeat(None, number)
   177         1       1072.0   1072.0      0.0          gcold = gc.isenabled()
   178         1        572.0    572.0      0.0          gc.disable()
   179         1        310.0    310.0      0.0          try:
   180         1      2.3e+10  2.3e+10    100.0              timing = self.inner(it, self.timer)
   181                                                   finally:
   182         1        471.0    471.0      0.0              if gcold:
   183         1    1126016.0 1.13e+06      0.0                  gc.enable()
   184         1       1120.0   1120.0      0.0          return timing

Total time: 0.635529 s
Average time: 1.0571e-05 s
File: /home/gblum/dev/dpc/utils.py
Function: CustomStateSpace.build_d_recursive at line 84

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    84                                               def build_d_recursive(self, y, v, current_d_list, current_d_sum, d_index, spot0):
    85                                                   """
    86                                                   Recursively builds the D-vector (d1, ..., dM) for a given
    87                                                   (y, v) prefix.
    88                                           
    89                                                   Pruning:
    90                                                   - sum(d) > X-1
    91                                                   - Trailing zeros (if d_i=0, all d_j for j>i must be 0)
    92                                                   - d2=0 if d1=0
    93                                                   """
    94                                                   # --- Base Case: D-vector is complete ---
    95     60120   23373607.0    388.8      3.7          if d_index == self.M:
    96                                                       # D-vector is built, now start building the H-vector
    97     38160   14777787.0    387.3      2.3              h_iterable = self.possible_h_iterables[spot0]
    98                                           
    99     38160   37542319.0    983.8      5.9              arr = self.state_to_index_array[y, v, *current_d_list, :]
   100     38160   16142794.0    423.0      2.5              final_d_list = tuple(current_d_list)
   101                                                       # 2. Loop over the product of these allowed H-options
   102    156960   47334685.0    301.6      7.4              for h_tuple in h_iterable:
   103                                                           global current_index
   104    118800   70998874.0    597.6     11.2                  arr[*h_tuple] = current_index
   105    118800   69654409.0    586.3     11.0                  self.valid_states_with_indices.append((y, v, final_d_list, h_tuple, current_index, spot0))
   106    118800   43361861.0    365.0      6.8                  current_index += 1
   107                                           
   108     38160   11233534.0    294.4      1.8              return        # --- Recursive Step: Add d_i ---
   109                                           
   110     21960    7231491.0    329.3      1.1          if d_index == 0:
   111      2520     990806.0    393.2      0.2              d_options = self.S_d1
   112     19440    6082020.0    312.9      1.0          elif spot0 > 0:
   113                                                       d_options = self.S_d0
   114                                                   else:
   115     19440    6551113.0    337.0      1.0              d_options = self.S_d
   116                                           
   117     82080   25980652.0    316.5      4.1          for d in d_options:
   118                                                       # 1. Sum constraint
   119     77040   32482435.0    421.6      5.1              if current_d_sum + d > self.X_limit:
   120     16920    5336324.0    315.4      0.8                  break # These are stored in increasing order
   121                                           
   122                                                       # 3. d1/d2 constraint (d1=0 -> d2>0)
   123                                                       # d_index == 1 is d2
   124     60120   19148012.0    318.5      3.0              if d_index == 1:
   125     40680   13456492.0    330.8      2.1                  d1 = current_d_list[0]
   126     40680   13697693.0    336.7      2.2                  if d1 == 0 and d == 0:
   127      2520     698869.0    277.3      0.1                      continue
   128                                           
   129     57600   23264183.0    403.9      3.7              if spot0 == 0 and d_index > 0 and d == 0:
   130     16920    5581463.0    329.9      0.9                  current_d_list[d_index] = d
   131     33840   12812429.0    378.6      2.0                  self.build_d_recursive(
   132     16920    5011294.0    296.2      0.8                      y, v,
   133     16920    4365124.0    258.0      0.7                      current_d_list,
   134     16920    5630160.0    332.8      0.9                      current_d_sum + d,
   135     16920    5431135.0    321.0      0.9                      d_index + 1,
   136     16920    4338610.0    256.4      0.7                      d_index # This is the first zero
   137                                                           )
   138                                                       else:
   139     40680   14239725.0    350.0      2.2                  current_d_list[d_index] = d
   140     81360   31361993.0    385.5      4.9                  self.build_d_recursive(
   141     40680   11060381.0    271.9      1.7                      y, v,
   142     40680   11055626.0    271.8      1.7                      current_d_list,
   143     40680   12143812.0    298.5      1.9                      current_d_sum + d,
   144     40680   12291710.0    302.2      1.9                      d_index + 1,
   145     40680   10865728.0    267.1      1.7                      spot0 # Zero spot unchanged
   146                                                           )

Total time: 1.17457 s
Average time: 0.0146822 s
File: /home/gblum/dev/dpc/utils.py
Function: CustomStateSpace.custom_state_space at line 148

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   148                                               def custom_state_space(self, C: Const) -> Tuple[int, np.ndarray, list]:
   149                                                   """
   150                                                   Computes the state space and returns a state -> index dictionary
   151                                                   using a recursive, pruning-based generation method.
   152                                           
   153                                                   This function maintains the strict lexicographical ordering
   154                                                   from the problem statement, ensuring the state-to-index
   155                                                   mapping is identical to the original 'itertools.product' method,
   156                                                   but is significantly faster by pruning invalid branches early.
   157                                                   """
   158                                                   global current_index
   159        80     131761.0   1647.0      0.0          current_index = 0
   160                                           
   161        80      78578.0    982.2      0.0          self.valid_states_with_indices = []
   162                                           
   163                                                   # --- Cache constants from C for minor speedup ---
   164        80     574398.0   7180.0      0.0          self.S_y, self.S_v = C.S_y, C.S_v
   165        80     545418.0   6817.7      0.0          self.S_d, self.S_d1 = sorted(C.S_d), sorted(C.S_d1)
   166        80      90923.0   1136.5      0.0          self.S_h, self.S_h_default = C.S_h, C.S_h[0]
   167        80     371544.0   4644.3      0.0          self.M, self.X_limit = C.M, C.X - 1
   168                                           
   169                                                   # --- Create mappings for non-contiguous state variables ---
   170        80      38494.0    481.2      0.0          self.v_offset = C.V_max
   171                                           
   172                                                   # --- Initialize state_to_index_array ---
   173        80      69626.0    870.3      0.0          dims = [C.Y, self.v_offset + 2 * C.V_max + 1]
   174       240     139788.0    582.5      0.0          for _ in range(self.M):
   175       160     107968.0    674.8      0.0              dims.append(C.X) # d values are 0..X-1
   176       240      92025.0    383.4      0.0          for _ in range(self.M):
   177       160      68496.0    428.1      0.0              dims.append(C.Y) # h values are 0..Y-1
   178                                           
   179        80   10068290.0 125853.6      0.9          self.state_to_index_array = np.full(dims, -1, dtype=np.int32)
   180                                           
   181                                           
   182                                                   # Pre-build the two possible lists for H-options
   183        80      79640.0    995.5      0.0          self.h_options_all = self.S_h
   184        80      51518.0    644.0      0.0          self.h_options_default = [self.S_h_default]
   185                                           
   186                                                   # Pre build an empty D-options list
   187        80      43093.0    538.7      0.0          self.S_d0 = [0]
   188                                           
   189        80     314037.0   3925.5      0.0          possible_h_iterables = [[self.h_options_all] + [self.h_options_all for i in range(1, self.M)]]
   190       160      82091.0    513.1      0.0          for spot0 in range(1, self.M):
   191       160     313191.0   1957.4      0.0              possible_h_iterables.append([self.h_options_all] + [
   192                                                           self.h_options_default if i >= spot0 else self.h_options_all
   193        80      38961.0    487.0      0.0                  for i in range(1, self.M)
   194                                                       ])
   195        80     414852.0   5185.6      0.0          self.possible_h_iterables = [list(product(*h_iter)) for h_iter in possible_h_iterables]
   196                                           
   197                                                   # The outer loops *must* be y, then v, to maintain order
   198       680     327587.0    481.7      0.0          for y in self.S_y:
   199      3120    1330094.0    426.3      0.1              for v in self.S_v:
   200      2520    1962726.0    778.9      0.2                  current_d_list_for_v = [0] * self.M
   201                                                           # Start the recursion for the D-vector
   202      2520 1157168633.0 459193.9     98.5                  self.build_d_recursive(y, v, current_d_list_for_v, 0, 0, 0)
   203                                           
   204        80      68518.0    856.5      0.0          return current_index, self.state_to_index_array, self.valid_states_with_indices

